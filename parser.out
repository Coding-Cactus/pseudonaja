Grammar:

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement statement_list
Rule 3     statement_list -> statement
Rule 4     empty -> <empty>
Rule 5     identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE
Rule 6     identifier_type -> IDENTIFIER : TYPE
Rule 7     identifier_type_list -> empty
Rule 8     identifier_type_list -> identifier_type , identifier_type_list
Rule 9     identifier_type_list -> identifier_type
Rule 10    statement -> ? IDENTIFIER
Rule 11    statement -> RETURN expression
Rule 12    statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
Rule 13    statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
Rule 14    statement -> REPEAT statement_list UNTIL expression
Rule 15    statement -> WHILE expression DO statement_list ENDWHILE
Rule 16    statement -> CASE OF expression caselist ENDCASE
Rule 17    statement -> IF expression THEN statement_list ELSE statement_list ENDIF
Rule 18    statement -> IF expression THEN statement_list ENDIF
Rule 19    statement -> OUTPUT arg_list
Rule 20    statement -> INPUT IDENTIFIER
Rule 21    statement -> CONSTANT IDENTIFIER = literal
Rule 22    statement -> variable ASSIGN expression  [precedence=right, level=1]
Rule 23    statement -> CALL IDENTIFIER
Rule 24    statement -> CALL IDENTIFIER ( arg_list )
Rule 25    statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
Rule 26    statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
Rule 27    statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
Rule 28    statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
Rule 29    statement -> DECLARE identifier_type
Rule 30    caselist -> a_case caselist
Rule 31    caselist -> a_case
Rule 32    a_case -> OTHERWISE : statement
Rule 33    a_case -> constant_label : statement
Rule 34    constant_label -> NUMBER
Rule 35    constant_label -> STRING
Rule 36    expression -> literal
Rule 37    expression -> IDENTIFIER ( )
Rule 38    expression -> IDENTIFIER ( arg_list )
Rule 39    expression -> expresssion_operation
Rule 40    expression -> ( expression )
Rule 41    arg_list -> expression , arg_list
Rule 42    arg_list -> expression
Rule 43    expresssion_operation -> expression AND expression  [precedence=left, level=3]
Rule 44    expresssion_operation -> expression OR expression  [precedence=left, level=2]
Rule 45    expresssion_operation -> expression SMALLER expression  [precedence=left, level=5]
Rule 46    expresssion_operation -> expression BIGGER expression  [precedence=left, level=5]
Rule 47    expresssion_operation -> expression NOTEQUAL expression  [precedence=left, level=4]
Rule 48    expresssion_operation -> expression EQUAL expression  [precedence=left, level=4]
Rule 49    expresssion_operation -> expression * expression  [precedence=left, level=7]
Rule 50    expresssion_operation -> expression / expression  [precedence=left, level=7]
Rule 51    expresssion_operation -> expression + expression  [precedence=left, level=6]
Rule 52    expresssion_operation -> expression - expression  [precedence=left, level=6]
Rule 53    literal -> IDENTIFIER
Rule 54    literal -> IDENTIFIER [ expression ]
Rule 55    literal -> STRING
Rule 56    literal -> BOOL
Rule 57    literal -> NUMBER . NUMBER
Rule 58    literal -> NUMBER
Rule 59    literal -> - NUMBER  [precedence=right, level=8]
Rule 60    variable -> IDENTIFIER
Rule 61    variable -> IDENTIFIER [ expression ]

Terminals, with rules where they appear:

(                    : 24 26 28 37 38 40
)                    : 24 26 28 37 38 40
*                    : 49
+                    : 51
,                    : 8 41
-                    : 52 59
.                    : 57
/                    : 50
:                    : 5 5 6 32 33
=                    : 21
?                    : 10
AND                  : 43
ARRAY                : 5
ASSIGN               : 12 13 22
BIGGER               : 46
BOOL                 : 56
CALL                 : 23 24
CASE                 : 16
CONSTANT             : 21
DECLARE              : 29
DO                   : 15
ELSE                 : 17
ENDCASE              : 16
ENDFUNCTION          : 25 26
ENDIF                : 17 18
ENDPROCEDURE         : 27 28
ENDWHILE             : 15
EQUAL                : 48
FOR                  : 12 13
FUNCTION             : 25 26
IDENTIFIER           : 5 6 10 12 13 20 21 23 24 25 26 27 28 37 38 53 54 60 61
IF                   : 17 18
INPUT                : 20
NEXT                 : 12 13
NOTEQUAL             : 47
NUMBER               : 5 5 34 57 57 58 59
OF                   : 5 16
OR                   : 44
OTHERWISE            : 32
OUTPUT               : 19
PROCEDURE            : 27 28
REPEAT               : 14
RETURN               : 11
RETURNS              : 25 26
SMALLER              : 45
STEP                 : 12
STRING               : 35 55
THEN                 : 17 18
TO                   : 12 13
TYPE                 : 5 6 25 26
UNTIL                : 14
WHILE                : 15
[                    : 5 54 61
]                    : 5 54 61
error                : 

Nonterminals, with rules where they appear:

a_case               : 30 31
arg_list             : 19 24 38 41
caselist             : 16 30
constant_label       : 33
empty                : 7
expression           : 11 12 12 12 13 13 14 15 16 17 18 22 40 41 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 54 61
expresssion_operation : 39
identifier_type      : 8 9 29
identifier_type_list : 8 26 28
literal              : 21 36
program              : 0
statement            : 2 3 32 33
statement_list       : 1 2 12 13 14 15 17 17 18 25 26 27 28
variable             : 22


state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 1

    (0) S' -> program .


state 2

    (1) program -> statement_list .
    $end            reduce using rule 1 (program -> statement_list .)


state 3

    (2) statement_list -> statement . statement_list
    (3) statement_list -> statement .
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    $end            reduce using rule 3 (statement_list -> statement .)
    UNTIL           reduce using rule 3 (statement_list -> statement .)
    ENDPROCEDURE    reduce using rule 3 (statement_list -> statement .)
    ENDWHILE        reduce using rule 3 (statement_list -> statement .)
    ELSE            reduce using rule 3 (statement_list -> statement .)
    ENDIF           reduce using rule 3 (statement_list -> statement .)
    ENDFUNCTION     reduce using rule 3 (statement_list -> statement .)
    NEXT            reduce using rule 3 (statement_list -> statement .)
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement                      shift and go to state 3
    statement_list                 shift and go to state 20
    variable                       shift and go to state 15

state 4

    (10) statement -> ? . IDENTIFIER
    IDENTIFIER      shift and go to state 21


state 5

    (60) variable -> IDENTIFIER .
    (61) variable -> IDENTIFIER . [ expression ]
    ASSIGN          reduce using rule 60 (variable -> IDENTIFIER .)
    [               shift and go to state 22


state 6

    (11) statement -> RETURN . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 23
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 7

    (12) statement -> FOR . IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> FOR . IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    IDENTIFIER      shift and go to state 32


state 8

    (14) statement -> REPEAT . statement_list UNTIL expression
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 33
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 9

    (15) statement -> WHILE . expression DO statement_list ENDWHILE
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 34
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 10

    (16) statement -> CASE . OF expression caselist ENDCASE
    OF              shift and go to state 35


state 11

    (17) statement -> IF . expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> IF . expression THEN statement_list ENDIF
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 36
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 12

    (19) statement -> OUTPUT . arg_list
    (41) arg_list -> . expression , arg_list
    (42) arg_list -> . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    arg_list                       shift and go to state 37
    expression                     shift and go to state 38
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 13

    (20) statement -> INPUT . IDENTIFIER
    IDENTIFIER      shift and go to state 39


state 14

    (21) statement -> CONSTANT . IDENTIFIER = literal
    IDENTIFIER      shift and go to state 40


state 15

    (22) statement -> variable . ASSIGN expression
    ASSIGN          shift and go to state 41


state 16

    (23) statement -> CALL . IDENTIFIER
    (24) statement -> CALL . IDENTIFIER ( arg_list )
    IDENTIFIER      shift and go to state 42


state 17

    (25) statement -> FUNCTION . IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> FUNCTION . IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    IDENTIFIER      shift and go to state 43


state 18

    (27) statement -> PROCEDURE . IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> PROCEDURE . IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    IDENTIFIER      shift and go to state 44


state 19

    (29) statement -> DECLARE . identifier_type
    (5) identifier_type -> . IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE
    (6) identifier_type -> . IDENTIFIER : TYPE
    IDENTIFIER      shift and go to state 46

    identifier_type                shift and go to state 45

state 20

    (2) statement_list -> statement statement_list .
    $end            reduce using rule 2 (statement_list -> statement statement_list .)
    UNTIL           reduce using rule 2 (statement_list -> statement statement_list .)
    ENDPROCEDURE    reduce using rule 2 (statement_list -> statement statement_list .)
    ENDWHILE        reduce using rule 2 (statement_list -> statement statement_list .)
    ELSE            reduce using rule 2 (statement_list -> statement statement_list .)
    ENDIF           reduce using rule 2 (statement_list -> statement statement_list .)
    ENDFUNCTION     reduce using rule 2 (statement_list -> statement statement_list .)
    NEXT            reduce using rule 2 (statement_list -> statement statement_list .)


state 21

    (10) statement -> ? IDENTIFIER .
    ?               reduce using rule 10 (statement -> ? IDENTIFIER .)
    RETURN          reduce using rule 10 (statement -> ? IDENTIFIER .)
    FOR             reduce using rule 10 (statement -> ? IDENTIFIER .)
    REPEAT          reduce using rule 10 (statement -> ? IDENTIFIER .)
    WHILE           reduce using rule 10 (statement -> ? IDENTIFIER .)
    CASE            reduce using rule 10 (statement -> ? IDENTIFIER .)
    IF              reduce using rule 10 (statement -> ? IDENTIFIER .)
    OUTPUT          reduce using rule 10 (statement -> ? IDENTIFIER .)
    INPUT           reduce using rule 10 (statement -> ? IDENTIFIER .)
    CONSTANT        reduce using rule 10 (statement -> ? IDENTIFIER .)
    CALL            reduce using rule 10 (statement -> ? IDENTIFIER .)
    FUNCTION        reduce using rule 10 (statement -> ? IDENTIFIER .)
    PROCEDURE       reduce using rule 10 (statement -> ? IDENTIFIER .)
    DECLARE         reduce using rule 10 (statement -> ? IDENTIFIER .)
    IDENTIFIER      reduce using rule 10 (statement -> ? IDENTIFIER .)
    $end            reduce using rule 10 (statement -> ? IDENTIFIER .)
    UNTIL           reduce using rule 10 (statement -> ? IDENTIFIER .)
    ENDPROCEDURE    reduce using rule 10 (statement -> ? IDENTIFIER .)
    ENDWHILE        reduce using rule 10 (statement -> ? IDENTIFIER .)
    ELSE            reduce using rule 10 (statement -> ? IDENTIFIER .)
    ENDIF           reduce using rule 10 (statement -> ? IDENTIFIER .)
    ENDFUNCTION     reduce using rule 10 (statement -> ? IDENTIFIER .)
    NEXT            reduce using rule 10 (statement -> ? IDENTIFIER .)
    OTHERWISE       reduce using rule 10 (statement -> ? IDENTIFIER .)
    NUMBER          reduce using rule 10 (statement -> ? IDENTIFIER .)
    STRING          reduce using rule 10 (statement -> ? IDENTIFIER .)
    ENDCASE         reduce using rule 10 (statement -> ? IDENTIFIER .)


state 22

    (61) variable -> IDENTIFIER [ . expression ]
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 47
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 23

    (11) statement -> RETURN expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    ?               reduce using rule 11 (statement -> RETURN expression .)
    RETURN          reduce using rule 11 (statement -> RETURN expression .)
    FOR             reduce using rule 11 (statement -> RETURN expression .)
    REPEAT          reduce using rule 11 (statement -> RETURN expression .)
    WHILE           reduce using rule 11 (statement -> RETURN expression .)
    CASE            reduce using rule 11 (statement -> RETURN expression .)
    IF              reduce using rule 11 (statement -> RETURN expression .)
    OUTPUT          reduce using rule 11 (statement -> RETURN expression .)
    INPUT           reduce using rule 11 (statement -> RETURN expression .)
    CONSTANT        reduce using rule 11 (statement -> RETURN expression .)
    CALL            reduce using rule 11 (statement -> RETURN expression .)
    FUNCTION        reduce using rule 11 (statement -> RETURN expression .)
    PROCEDURE       reduce using rule 11 (statement -> RETURN expression .)
    DECLARE         reduce using rule 11 (statement -> RETURN expression .)
    IDENTIFIER      reduce using rule 11 (statement -> RETURN expression .)
    $end            reduce using rule 11 (statement -> RETURN expression .)
    UNTIL           reduce using rule 11 (statement -> RETURN expression .)
    ENDPROCEDURE    reduce using rule 11 (statement -> RETURN expression .)
    ENDWHILE        reduce using rule 11 (statement -> RETURN expression .)
    ELSE            reduce using rule 11 (statement -> RETURN expression .)
    ENDIF           reduce using rule 11 (statement -> RETURN expression .)
    ENDFUNCTION     reduce using rule 11 (statement -> RETURN expression .)
    NEXT            reduce using rule 11 (statement -> RETURN expression .)
    OTHERWISE       reduce using rule 11 (statement -> RETURN expression .)
    NUMBER          reduce using rule 11 (statement -> RETURN expression .)
    STRING          reduce using rule 11 (statement -> RETURN expression .)
    ENDCASE         reduce using rule 11 (statement -> RETURN expression .)
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 24

    (36) expression -> literal .
    AND             reduce using rule 36 (expression -> literal .)
    OR              reduce using rule 36 (expression -> literal .)
    SMALLER         reduce using rule 36 (expression -> literal .)
    BIGGER          reduce using rule 36 (expression -> literal .)
    NOTEQUAL        reduce using rule 36 (expression -> literal .)
    EQUAL           reduce using rule 36 (expression -> literal .)
    *               reduce using rule 36 (expression -> literal .)
    /               reduce using rule 36 (expression -> literal .)
    +               reduce using rule 36 (expression -> literal .)
    -               reduce using rule 36 (expression -> literal .)
    ?               reduce using rule 36 (expression -> literal .)
    RETURN          reduce using rule 36 (expression -> literal .)
    FOR             reduce using rule 36 (expression -> literal .)
    REPEAT          reduce using rule 36 (expression -> literal .)
    WHILE           reduce using rule 36 (expression -> literal .)
    CASE            reduce using rule 36 (expression -> literal .)
    IF              reduce using rule 36 (expression -> literal .)
    OUTPUT          reduce using rule 36 (expression -> literal .)
    INPUT           reduce using rule 36 (expression -> literal .)
    CONSTANT        reduce using rule 36 (expression -> literal .)
    CALL            reduce using rule 36 (expression -> literal .)
    FUNCTION        reduce using rule 36 (expression -> literal .)
    PROCEDURE       reduce using rule 36 (expression -> literal .)
    DECLARE         reduce using rule 36 (expression -> literal .)
    IDENTIFIER      reduce using rule 36 (expression -> literal .)
    $end            reduce using rule 36 (expression -> literal .)
    UNTIL           reduce using rule 36 (expression -> literal .)
    ENDPROCEDURE    reduce using rule 36 (expression -> literal .)
    ENDWHILE        reduce using rule 36 (expression -> literal .)
    ELSE            reduce using rule 36 (expression -> literal .)
    ENDIF           reduce using rule 36 (expression -> literal .)
    ENDFUNCTION     reduce using rule 36 (expression -> literal .)
    NEXT            reduce using rule 36 (expression -> literal .)
    OTHERWISE       reduce using rule 36 (expression -> literal .)
    NUMBER          reduce using rule 36 (expression -> literal .)
    STRING          reduce using rule 36 (expression -> literal .)
    ENDCASE         reduce using rule 36 (expression -> literal .)
    DO              reduce using rule 36 (expression -> literal .)
    THEN            reduce using rule 36 (expression -> literal .)
    ,               reduce using rule 36 (expression -> literal .)
    ]               reduce using rule 36 (expression -> literal .)
    )               reduce using rule 36 (expression -> literal .)
    TO              reduce using rule 36 (expression -> literal .)
    STEP            reduce using rule 36 (expression -> literal .)


state 25

    (37) expression -> IDENTIFIER . ( )
    (38) expression -> IDENTIFIER . ( arg_list )
    (53) literal -> IDENTIFIER .
    (54) literal -> IDENTIFIER . [ expression ]
    (               shift and go to state 58
    AND             reduce using rule 53 (literal -> IDENTIFIER .)
    OR              reduce using rule 53 (literal -> IDENTIFIER .)
    SMALLER         reduce using rule 53 (literal -> IDENTIFIER .)
    BIGGER          reduce using rule 53 (literal -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 53 (literal -> IDENTIFIER .)
    EQUAL           reduce using rule 53 (literal -> IDENTIFIER .)
    *               reduce using rule 53 (literal -> IDENTIFIER .)
    /               reduce using rule 53 (literal -> IDENTIFIER .)
    +               reduce using rule 53 (literal -> IDENTIFIER .)
    -               reduce using rule 53 (literal -> IDENTIFIER .)
    ?               reduce using rule 53 (literal -> IDENTIFIER .)
    RETURN          reduce using rule 53 (literal -> IDENTIFIER .)
    FOR             reduce using rule 53 (literal -> IDENTIFIER .)
    REPEAT          reduce using rule 53 (literal -> IDENTIFIER .)
    WHILE           reduce using rule 53 (literal -> IDENTIFIER .)
    CASE            reduce using rule 53 (literal -> IDENTIFIER .)
    IF              reduce using rule 53 (literal -> IDENTIFIER .)
    OUTPUT          reduce using rule 53 (literal -> IDENTIFIER .)
    INPUT           reduce using rule 53 (literal -> IDENTIFIER .)
    CONSTANT        reduce using rule 53 (literal -> IDENTIFIER .)
    CALL            reduce using rule 53 (literal -> IDENTIFIER .)
    FUNCTION        reduce using rule 53 (literal -> IDENTIFIER .)
    PROCEDURE       reduce using rule 53 (literal -> IDENTIFIER .)
    DECLARE         reduce using rule 53 (literal -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 53 (literal -> IDENTIFIER .)
    $end            reduce using rule 53 (literal -> IDENTIFIER .)
    UNTIL           reduce using rule 53 (literal -> IDENTIFIER .)
    ENDPROCEDURE    reduce using rule 53 (literal -> IDENTIFIER .)
    ENDWHILE        reduce using rule 53 (literal -> IDENTIFIER .)
    ELSE            reduce using rule 53 (literal -> IDENTIFIER .)
    ENDIF           reduce using rule 53 (literal -> IDENTIFIER .)
    ENDFUNCTION     reduce using rule 53 (literal -> IDENTIFIER .)
    NEXT            reduce using rule 53 (literal -> IDENTIFIER .)
    OTHERWISE       reduce using rule 53 (literal -> IDENTIFIER .)
    NUMBER          reduce using rule 53 (literal -> IDENTIFIER .)
    STRING          reduce using rule 53 (literal -> IDENTIFIER .)
    ENDCASE         reduce using rule 53 (literal -> IDENTIFIER .)
    DO              reduce using rule 53 (literal -> IDENTIFIER .)
    THEN            reduce using rule 53 (literal -> IDENTIFIER .)
    ,               reduce using rule 53 (literal -> IDENTIFIER .)
    ]               reduce using rule 53 (literal -> IDENTIFIER .)
    )               reduce using rule 53 (literal -> IDENTIFIER .)
    TO              reduce using rule 53 (literal -> IDENTIFIER .)
    STEP            reduce using rule 53 (literal -> IDENTIFIER .)
    [               shift and go to state 59


state 26

    (40) expression -> ( . expression )
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 60
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 27

    (39) expression -> expresssion_operation .
    AND             reduce using rule 39 (expression -> expresssion_operation .)
    OR              reduce using rule 39 (expression -> expresssion_operation .)
    SMALLER         reduce using rule 39 (expression -> expresssion_operation .)
    BIGGER          reduce using rule 39 (expression -> expresssion_operation .)
    NOTEQUAL        reduce using rule 39 (expression -> expresssion_operation .)
    EQUAL           reduce using rule 39 (expression -> expresssion_operation .)
    *               reduce using rule 39 (expression -> expresssion_operation .)
    /               reduce using rule 39 (expression -> expresssion_operation .)
    +               reduce using rule 39 (expression -> expresssion_operation .)
    -               reduce using rule 39 (expression -> expresssion_operation .)
    ?               reduce using rule 39 (expression -> expresssion_operation .)
    RETURN          reduce using rule 39 (expression -> expresssion_operation .)
    FOR             reduce using rule 39 (expression -> expresssion_operation .)
    REPEAT          reduce using rule 39 (expression -> expresssion_operation .)
    WHILE           reduce using rule 39 (expression -> expresssion_operation .)
    CASE            reduce using rule 39 (expression -> expresssion_operation .)
    IF              reduce using rule 39 (expression -> expresssion_operation .)
    OUTPUT          reduce using rule 39 (expression -> expresssion_operation .)
    INPUT           reduce using rule 39 (expression -> expresssion_operation .)
    CONSTANT        reduce using rule 39 (expression -> expresssion_operation .)
    CALL            reduce using rule 39 (expression -> expresssion_operation .)
    FUNCTION        reduce using rule 39 (expression -> expresssion_operation .)
    PROCEDURE       reduce using rule 39 (expression -> expresssion_operation .)
    DECLARE         reduce using rule 39 (expression -> expresssion_operation .)
    IDENTIFIER      reduce using rule 39 (expression -> expresssion_operation .)
    $end            reduce using rule 39 (expression -> expresssion_operation .)
    UNTIL           reduce using rule 39 (expression -> expresssion_operation .)
    ENDPROCEDURE    reduce using rule 39 (expression -> expresssion_operation .)
    ENDWHILE        reduce using rule 39 (expression -> expresssion_operation .)
    ELSE            reduce using rule 39 (expression -> expresssion_operation .)
    ENDIF           reduce using rule 39 (expression -> expresssion_operation .)
    ENDFUNCTION     reduce using rule 39 (expression -> expresssion_operation .)
    NEXT            reduce using rule 39 (expression -> expresssion_operation .)
    OTHERWISE       reduce using rule 39 (expression -> expresssion_operation .)
    NUMBER          reduce using rule 39 (expression -> expresssion_operation .)
    STRING          reduce using rule 39 (expression -> expresssion_operation .)
    ENDCASE         reduce using rule 39 (expression -> expresssion_operation .)
    DO              reduce using rule 39 (expression -> expresssion_operation .)
    THEN            reduce using rule 39 (expression -> expresssion_operation .)
    ,               reduce using rule 39 (expression -> expresssion_operation .)
    ]               reduce using rule 39 (expression -> expresssion_operation .)
    )               reduce using rule 39 (expression -> expresssion_operation .)
    TO              reduce using rule 39 (expression -> expresssion_operation .)
    STEP            reduce using rule 39 (expression -> expresssion_operation .)


state 28

    (55) literal -> STRING .
    AND             reduce using rule 55 (literal -> STRING .)
    OR              reduce using rule 55 (literal -> STRING .)
    SMALLER         reduce using rule 55 (literal -> STRING .)
    BIGGER          reduce using rule 55 (literal -> STRING .)
    NOTEQUAL        reduce using rule 55 (literal -> STRING .)
    EQUAL           reduce using rule 55 (literal -> STRING .)
    *               reduce using rule 55 (literal -> STRING .)
    /               reduce using rule 55 (literal -> STRING .)
    +               reduce using rule 55 (literal -> STRING .)
    -               reduce using rule 55 (literal -> STRING .)
    ?               reduce using rule 55 (literal -> STRING .)
    RETURN          reduce using rule 55 (literal -> STRING .)
    FOR             reduce using rule 55 (literal -> STRING .)
    REPEAT          reduce using rule 55 (literal -> STRING .)
    WHILE           reduce using rule 55 (literal -> STRING .)
    CASE            reduce using rule 55 (literal -> STRING .)
    IF              reduce using rule 55 (literal -> STRING .)
    OUTPUT          reduce using rule 55 (literal -> STRING .)
    INPUT           reduce using rule 55 (literal -> STRING .)
    CONSTANT        reduce using rule 55 (literal -> STRING .)
    CALL            reduce using rule 55 (literal -> STRING .)
    FUNCTION        reduce using rule 55 (literal -> STRING .)
    PROCEDURE       reduce using rule 55 (literal -> STRING .)
    DECLARE         reduce using rule 55 (literal -> STRING .)
    IDENTIFIER      reduce using rule 55 (literal -> STRING .)
    $end            reduce using rule 55 (literal -> STRING .)
    UNTIL           reduce using rule 55 (literal -> STRING .)
    ENDPROCEDURE    reduce using rule 55 (literal -> STRING .)
    ENDWHILE        reduce using rule 55 (literal -> STRING .)
    ELSE            reduce using rule 55 (literal -> STRING .)
    ENDIF           reduce using rule 55 (literal -> STRING .)
    ENDFUNCTION     reduce using rule 55 (literal -> STRING .)
    NEXT            reduce using rule 55 (literal -> STRING .)
    OTHERWISE       reduce using rule 55 (literal -> STRING .)
    NUMBER          reduce using rule 55 (literal -> STRING .)
    STRING          reduce using rule 55 (literal -> STRING .)
    ENDCASE         reduce using rule 55 (literal -> STRING .)
    DO              reduce using rule 55 (literal -> STRING .)
    THEN            reduce using rule 55 (literal -> STRING .)
    ,               reduce using rule 55 (literal -> STRING .)
    ]               reduce using rule 55 (literal -> STRING .)
    )               reduce using rule 55 (literal -> STRING .)
    TO              reduce using rule 55 (literal -> STRING .)
    STEP            reduce using rule 55 (literal -> STRING .)


state 29

    (56) literal -> BOOL .
    AND             reduce using rule 56 (literal -> BOOL .)
    OR              reduce using rule 56 (literal -> BOOL .)
    SMALLER         reduce using rule 56 (literal -> BOOL .)
    BIGGER          reduce using rule 56 (literal -> BOOL .)
    NOTEQUAL        reduce using rule 56 (literal -> BOOL .)
    EQUAL           reduce using rule 56 (literal -> BOOL .)
    *               reduce using rule 56 (literal -> BOOL .)
    /               reduce using rule 56 (literal -> BOOL .)
    +               reduce using rule 56 (literal -> BOOL .)
    -               reduce using rule 56 (literal -> BOOL .)
    ?               reduce using rule 56 (literal -> BOOL .)
    RETURN          reduce using rule 56 (literal -> BOOL .)
    FOR             reduce using rule 56 (literal -> BOOL .)
    REPEAT          reduce using rule 56 (literal -> BOOL .)
    WHILE           reduce using rule 56 (literal -> BOOL .)
    CASE            reduce using rule 56 (literal -> BOOL .)
    IF              reduce using rule 56 (literal -> BOOL .)
    OUTPUT          reduce using rule 56 (literal -> BOOL .)
    INPUT           reduce using rule 56 (literal -> BOOL .)
    CONSTANT        reduce using rule 56 (literal -> BOOL .)
    CALL            reduce using rule 56 (literal -> BOOL .)
    FUNCTION        reduce using rule 56 (literal -> BOOL .)
    PROCEDURE       reduce using rule 56 (literal -> BOOL .)
    DECLARE         reduce using rule 56 (literal -> BOOL .)
    IDENTIFIER      reduce using rule 56 (literal -> BOOL .)
    $end            reduce using rule 56 (literal -> BOOL .)
    UNTIL           reduce using rule 56 (literal -> BOOL .)
    ENDPROCEDURE    reduce using rule 56 (literal -> BOOL .)
    ENDWHILE        reduce using rule 56 (literal -> BOOL .)
    ELSE            reduce using rule 56 (literal -> BOOL .)
    ENDIF           reduce using rule 56 (literal -> BOOL .)
    ENDFUNCTION     reduce using rule 56 (literal -> BOOL .)
    NEXT            reduce using rule 56 (literal -> BOOL .)
    OTHERWISE       reduce using rule 56 (literal -> BOOL .)
    NUMBER          reduce using rule 56 (literal -> BOOL .)
    STRING          reduce using rule 56 (literal -> BOOL .)
    ENDCASE         reduce using rule 56 (literal -> BOOL .)
    DO              reduce using rule 56 (literal -> BOOL .)
    THEN            reduce using rule 56 (literal -> BOOL .)
    ,               reduce using rule 56 (literal -> BOOL .)
    ]               reduce using rule 56 (literal -> BOOL .)
    )               reduce using rule 56 (literal -> BOOL .)
    TO              reduce using rule 56 (literal -> BOOL .)
    STEP            reduce using rule 56 (literal -> BOOL .)


state 30

    (57) literal -> NUMBER . . NUMBER
    (58) literal -> NUMBER .
    .               shift and go to state 61
    AND             reduce using rule 58 (literal -> NUMBER .)
    OR              reduce using rule 58 (literal -> NUMBER .)
    SMALLER         reduce using rule 58 (literal -> NUMBER .)
    BIGGER          reduce using rule 58 (literal -> NUMBER .)
    NOTEQUAL        reduce using rule 58 (literal -> NUMBER .)
    EQUAL           reduce using rule 58 (literal -> NUMBER .)
    *               reduce using rule 58 (literal -> NUMBER .)
    /               reduce using rule 58 (literal -> NUMBER .)
    +               reduce using rule 58 (literal -> NUMBER .)
    -               reduce using rule 58 (literal -> NUMBER .)
    ?               reduce using rule 58 (literal -> NUMBER .)
    RETURN          reduce using rule 58 (literal -> NUMBER .)
    FOR             reduce using rule 58 (literal -> NUMBER .)
    REPEAT          reduce using rule 58 (literal -> NUMBER .)
    WHILE           reduce using rule 58 (literal -> NUMBER .)
    CASE            reduce using rule 58 (literal -> NUMBER .)
    IF              reduce using rule 58 (literal -> NUMBER .)
    OUTPUT          reduce using rule 58 (literal -> NUMBER .)
    INPUT           reduce using rule 58 (literal -> NUMBER .)
    CONSTANT        reduce using rule 58 (literal -> NUMBER .)
    CALL            reduce using rule 58 (literal -> NUMBER .)
    FUNCTION        reduce using rule 58 (literal -> NUMBER .)
    PROCEDURE       reduce using rule 58 (literal -> NUMBER .)
    DECLARE         reduce using rule 58 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 58 (literal -> NUMBER .)
    $end            reduce using rule 58 (literal -> NUMBER .)
    UNTIL           reduce using rule 58 (literal -> NUMBER .)
    ENDPROCEDURE    reduce using rule 58 (literal -> NUMBER .)
    ENDWHILE        reduce using rule 58 (literal -> NUMBER .)
    ELSE            reduce using rule 58 (literal -> NUMBER .)
    ENDIF           reduce using rule 58 (literal -> NUMBER .)
    ENDFUNCTION     reduce using rule 58 (literal -> NUMBER .)
    NEXT            reduce using rule 58 (literal -> NUMBER .)
    OTHERWISE       reduce using rule 58 (literal -> NUMBER .)
    NUMBER          reduce using rule 58 (literal -> NUMBER .)
    STRING          reduce using rule 58 (literal -> NUMBER .)
    ENDCASE         reduce using rule 58 (literal -> NUMBER .)
    DO              reduce using rule 58 (literal -> NUMBER .)
    THEN            reduce using rule 58 (literal -> NUMBER .)
    ,               reduce using rule 58 (literal -> NUMBER .)
    ]               reduce using rule 58 (literal -> NUMBER .)
    )               reduce using rule 58 (literal -> NUMBER .)
    TO              reduce using rule 58 (literal -> NUMBER .)
    STEP            reduce using rule 58 (literal -> NUMBER .)


state 31

    (59) literal -> - . NUMBER
    NUMBER          shift and go to state 62


state 32

    (12) statement -> FOR IDENTIFIER . ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> FOR IDENTIFIER . ASSIGN expression TO expression statement_list NEXT
    ASSIGN          shift and go to state 63


state 33

    (14) statement -> REPEAT statement_list . UNTIL expression
    UNTIL           shift and go to state 64


state 34

    (15) statement -> WHILE expression . DO statement_list ENDWHILE
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    DO              shift and go to state 65
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 35

    (16) statement -> CASE OF . expression caselist ENDCASE
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 66
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 36

    (17) statement -> IF expression . THEN statement_list ELSE statement_list ENDIF
    (18) statement -> IF expression . THEN statement_list ENDIF
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    THEN            shift and go to state 67
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 37

    (19) statement -> OUTPUT arg_list .
    ?               reduce using rule 19 (statement -> OUTPUT arg_list .)
    RETURN          reduce using rule 19 (statement -> OUTPUT arg_list .)
    FOR             reduce using rule 19 (statement -> OUTPUT arg_list .)
    REPEAT          reduce using rule 19 (statement -> OUTPUT arg_list .)
    WHILE           reduce using rule 19 (statement -> OUTPUT arg_list .)
    CASE            reduce using rule 19 (statement -> OUTPUT arg_list .)
    IF              reduce using rule 19 (statement -> OUTPUT arg_list .)
    OUTPUT          reduce using rule 19 (statement -> OUTPUT arg_list .)
    INPUT           reduce using rule 19 (statement -> OUTPUT arg_list .)
    CONSTANT        reduce using rule 19 (statement -> OUTPUT arg_list .)
    CALL            reduce using rule 19 (statement -> OUTPUT arg_list .)
    FUNCTION        reduce using rule 19 (statement -> OUTPUT arg_list .)
    PROCEDURE       reduce using rule 19 (statement -> OUTPUT arg_list .)
    DECLARE         reduce using rule 19 (statement -> OUTPUT arg_list .)
    IDENTIFIER      reduce using rule 19 (statement -> OUTPUT arg_list .)
    $end            reduce using rule 19 (statement -> OUTPUT arg_list .)
    UNTIL           reduce using rule 19 (statement -> OUTPUT arg_list .)
    ENDPROCEDURE    reduce using rule 19 (statement -> OUTPUT arg_list .)
    ENDWHILE        reduce using rule 19 (statement -> OUTPUT arg_list .)
    ELSE            reduce using rule 19 (statement -> OUTPUT arg_list .)
    ENDIF           reduce using rule 19 (statement -> OUTPUT arg_list .)
    ENDFUNCTION     reduce using rule 19 (statement -> OUTPUT arg_list .)
    NEXT            reduce using rule 19 (statement -> OUTPUT arg_list .)
    OTHERWISE       reduce using rule 19 (statement -> OUTPUT arg_list .)
    NUMBER          reduce using rule 19 (statement -> OUTPUT arg_list .)
    STRING          reduce using rule 19 (statement -> OUTPUT arg_list .)
    ENDCASE         reduce using rule 19 (statement -> OUTPUT arg_list .)


state 38

    (41) arg_list -> expression . , arg_list
    (42) arg_list -> expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    ,               shift and go to state 68
    ?               reduce using rule 42 (arg_list -> expression .)
    RETURN          reduce using rule 42 (arg_list -> expression .)
    FOR             reduce using rule 42 (arg_list -> expression .)
    REPEAT          reduce using rule 42 (arg_list -> expression .)
    WHILE           reduce using rule 42 (arg_list -> expression .)
    CASE            reduce using rule 42 (arg_list -> expression .)
    IF              reduce using rule 42 (arg_list -> expression .)
    OUTPUT          reduce using rule 42 (arg_list -> expression .)
    INPUT           reduce using rule 42 (arg_list -> expression .)
    CONSTANT        reduce using rule 42 (arg_list -> expression .)
    CALL            reduce using rule 42 (arg_list -> expression .)
    FUNCTION        reduce using rule 42 (arg_list -> expression .)
    PROCEDURE       reduce using rule 42 (arg_list -> expression .)
    DECLARE         reduce using rule 42 (arg_list -> expression .)
    IDENTIFIER      reduce using rule 42 (arg_list -> expression .)
    $end            reduce using rule 42 (arg_list -> expression .)
    UNTIL           reduce using rule 42 (arg_list -> expression .)
    ENDPROCEDURE    reduce using rule 42 (arg_list -> expression .)
    ENDWHILE        reduce using rule 42 (arg_list -> expression .)
    ELSE            reduce using rule 42 (arg_list -> expression .)
    ENDIF           reduce using rule 42 (arg_list -> expression .)
    ENDFUNCTION     reduce using rule 42 (arg_list -> expression .)
    NEXT            reduce using rule 42 (arg_list -> expression .)
    OTHERWISE       reduce using rule 42 (arg_list -> expression .)
    NUMBER          reduce using rule 42 (arg_list -> expression .)
    STRING          reduce using rule 42 (arg_list -> expression .)
    ENDCASE         reduce using rule 42 (arg_list -> expression .)
    )               reduce using rule 42 (arg_list -> expression .)
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 39

    (20) statement -> INPUT IDENTIFIER .
    ?               reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    RETURN          reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    FOR             reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    REPEAT          reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    WHILE           reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    CASE            reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    IF              reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    OUTPUT          reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    INPUT           reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    CONSTANT        reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    CALL            reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    FUNCTION        reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    PROCEDURE       reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    DECLARE         reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    IDENTIFIER      reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    $end            reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    UNTIL           reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    ENDPROCEDURE    reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    ENDWHILE        reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    ELSE            reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    ENDIF           reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    ENDFUNCTION     reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    NEXT            reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    OTHERWISE       reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    NUMBER          reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    STRING          reduce using rule 20 (statement -> INPUT IDENTIFIER .)
    ENDCASE         reduce using rule 20 (statement -> INPUT IDENTIFIER .)


state 40

    (21) statement -> CONSTANT IDENTIFIER . = literal
    =               shift and go to state 69


state 41

    (22) statement -> variable ASSIGN . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 70
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 42

    (23) statement -> CALL IDENTIFIER .
    (24) statement -> CALL IDENTIFIER . ( arg_list )
    ?               reduce using rule 23 (statement -> CALL IDENTIFIER .)
    RETURN          reduce using rule 23 (statement -> CALL IDENTIFIER .)
    FOR             reduce using rule 23 (statement -> CALL IDENTIFIER .)
    REPEAT          reduce using rule 23 (statement -> CALL IDENTIFIER .)
    WHILE           reduce using rule 23 (statement -> CALL IDENTIFIER .)
    CASE            reduce using rule 23 (statement -> CALL IDENTIFIER .)
    IF              reduce using rule 23 (statement -> CALL IDENTIFIER .)
    OUTPUT          reduce using rule 23 (statement -> CALL IDENTIFIER .)
    INPUT           reduce using rule 23 (statement -> CALL IDENTIFIER .)
    CONSTANT        reduce using rule 23 (statement -> CALL IDENTIFIER .)
    CALL            reduce using rule 23 (statement -> CALL IDENTIFIER .)
    FUNCTION        reduce using rule 23 (statement -> CALL IDENTIFIER .)
    PROCEDURE       reduce using rule 23 (statement -> CALL IDENTIFIER .)
    DECLARE         reduce using rule 23 (statement -> CALL IDENTIFIER .)
    IDENTIFIER      reduce using rule 23 (statement -> CALL IDENTIFIER .)
    $end            reduce using rule 23 (statement -> CALL IDENTIFIER .)
    UNTIL           reduce using rule 23 (statement -> CALL IDENTIFIER .)
    ENDPROCEDURE    reduce using rule 23 (statement -> CALL IDENTIFIER .)
    ENDWHILE        reduce using rule 23 (statement -> CALL IDENTIFIER .)
    ELSE            reduce using rule 23 (statement -> CALL IDENTIFIER .)
    ENDIF           reduce using rule 23 (statement -> CALL IDENTIFIER .)
    ENDFUNCTION     reduce using rule 23 (statement -> CALL IDENTIFIER .)
    NEXT            reduce using rule 23 (statement -> CALL IDENTIFIER .)
    OTHERWISE       reduce using rule 23 (statement -> CALL IDENTIFIER .)
    NUMBER          reduce using rule 23 (statement -> CALL IDENTIFIER .)
    STRING          reduce using rule 23 (statement -> CALL IDENTIFIER .)
    ENDCASE         reduce using rule 23 (statement -> CALL IDENTIFIER .)
    (               shift and go to state 71


state 43

    (25) statement -> FUNCTION IDENTIFIER . RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> FUNCTION IDENTIFIER . ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    RETURNS         shift and go to state 72
    (               shift and go to state 73


state 44

    (27) statement -> PROCEDURE IDENTIFIER . statement_list ENDPROCEDURE
    (28) statement -> PROCEDURE IDENTIFIER . ( identifier_type_list ) statement_list ENDPROCEDURE
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    (               shift and go to state 75
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 74
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 45

    (29) statement -> DECLARE identifier_type .
    ?               reduce using rule 29 (statement -> DECLARE identifier_type .)
    RETURN          reduce using rule 29 (statement -> DECLARE identifier_type .)
    FOR             reduce using rule 29 (statement -> DECLARE identifier_type .)
    REPEAT          reduce using rule 29 (statement -> DECLARE identifier_type .)
    WHILE           reduce using rule 29 (statement -> DECLARE identifier_type .)
    CASE            reduce using rule 29 (statement -> DECLARE identifier_type .)
    IF              reduce using rule 29 (statement -> DECLARE identifier_type .)
    OUTPUT          reduce using rule 29 (statement -> DECLARE identifier_type .)
    INPUT           reduce using rule 29 (statement -> DECLARE identifier_type .)
    CONSTANT        reduce using rule 29 (statement -> DECLARE identifier_type .)
    CALL            reduce using rule 29 (statement -> DECLARE identifier_type .)
    FUNCTION        reduce using rule 29 (statement -> DECLARE identifier_type .)
    PROCEDURE       reduce using rule 29 (statement -> DECLARE identifier_type .)
    DECLARE         reduce using rule 29 (statement -> DECLARE identifier_type .)
    IDENTIFIER      reduce using rule 29 (statement -> DECLARE identifier_type .)
    $end            reduce using rule 29 (statement -> DECLARE identifier_type .)
    UNTIL           reduce using rule 29 (statement -> DECLARE identifier_type .)
    ENDPROCEDURE    reduce using rule 29 (statement -> DECLARE identifier_type .)
    ENDWHILE        reduce using rule 29 (statement -> DECLARE identifier_type .)
    ELSE            reduce using rule 29 (statement -> DECLARE identifier_type .)
    ENDIF           reduce using rule 29 (statement -> DECLARE identifier_type .)
    ENDFUNCTION     reduce using rule 29 (statement -> DECLARE identifier_type .)
    NEXT            reduce using rule 29 (statement -> DECLARE identifier_type .)
    OTHERWISE       reduce using rule 29 (statement -> DECLARE identifier_type .)
    NUMBER          reduce using rule 29 (statement -> DECLARE identifier_type .)
    STRING          reduce using rule 29 (statement -> DECLARE identifier_type .)
    ENDCASE         reduce using rule 29 (statement -> DECLARE identifier_type .)


state 46

    (5) identifier_type -> IDENTIFIER . : ARRAY [ NUMBER : NUMBER ] OF TYPE
    (6) identifier_type -> IDENTIFIER . : TYPE
    :               shift and go to state 76


state 47

    (61) variable -> IDENTIFIER [ expression . ]
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    ]               shift and go to state 77
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 48

    (43) expresssion_operation -> expression AND . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 78
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 49

    (44) expresssion_operation -> expression OR . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 79
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 50

    (45) expresssion_operation -> expression SMALLER . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 80
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 51

    (46) expresssion_operation -> expression BIGGER . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 81
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 52

    (47) expresssion_operation -> expression NOTEQUAL . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 82
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 53

    (48) expresssion_operation -> expression EQUAL . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 83
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 54

    (49) expresssion_operation -> expression * . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 84
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 55

    (50) expresssion_operation -> expression / . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 85
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 56

    (51) expresssion_operation -> expression + . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 86
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 57

    (52) expresssion_operation -> expression - . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 87
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 58

    (37) expression -> IDENTIFIER ( . )
    (38) expression -> IDENTIFIER ( . arg_list )
    (41) arg_list -> . expression , arg_list
    (42) arg_list -> . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    )               shift and go to state 88
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    arg_list                       shift and go to state 89
    expression                     shift and go to state 38
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 59

    (54) literal -> IDENTIFIER [ . expression ]
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 90
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 60

    (40) expression -> ( expression . )
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    )               shift and go to state 91
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 61

    (57) literal -> NUMBER . . NUMBER
    NUMBER          shift and go to state 92


state 62

    (59) literal -> - NUMBER .
    AND             reduce using rule 59 (literal -> - NUMBER .)
    OR              reduce using rule 59 (literal -> - NUMBER .)
    SMALLER         reduce using rule 59 (literal -> - NUMBER .)
    BIGGER          reduce using rule 59 (literal -> - NUMBER .)
    NOTEQUAL        reduce using rule 59 (literal -> - NUMBER .)
    EQUAL           reduce using rule 59 (literal -> - NUMBER .)
    *               reduce using rule 59 (literal -> - NUMBER .)
    /               reduce using rule 59 (literal -> - NUMBER .)
    +               reduce using rule 59 (literal -> - NUMBER .)
    -               reduce using rule 59 (literal -> - NUMBER .)
    ?               reduce using rule 59 (literal -> - NUMBER .)
    RETURN          reduce using rule 59 (literal -> - NUMBER .)
    FOR             reduce using rule 59 (literal -> - NUMBER .)
    REPEAT          reduce using rule 59 (literal -> - NUMBER .)
    WHILE           reduce using rule 59 (literal -> - NUMBER .)
    CASE            reduce using rule 59 (literal -> - NUMBER .)
    IF              reduce using rule 59 (literal -> - NUMBER .)
    OUTPUT          reduce using rule 59 (literal -> - NUMBER .)
    INPUT           reduce using rule 59 (literal -> - NUMBER .)
    CONSTANT        reduce using rule 59 (literal -> - NUMBER .)
    CALL            reduce using rule 59 (literal -> - NUMBER .)
    FUNCTION        reduce using rule 59 (literal -> - NUMBER .)
    PROCEDURE       reduce using rule 59 (literal -> - NUMBER .)
    DECLARE         reduce using rule 59 (literal -> - NUMBER .)
    IDENTIFIER      reduce using rule 59 (literal -> - NUMBER .)
    $end            reduce using rule 59 (literal -> - NUMBER .)
    UNTIL           reduce using rule 59 (literal -> - NUMBER .)
    ENDPROCEDURE    reduce using rule 59 (literal -> - NUMBER .)
    ENDWHILE        reduce using rule 59 (literal -> - NUMBER .)
    ELSE            reduce using rule 59 (literal -> - NUMBER .)
    ENDIF           reduce using rule 59 (literal -> - NUMBER .)
    ENDFUNCTION     reduce using rule 59 (literal -> - NUMBER .)
    NEXT            reduce using rule 59 (literal -> - NUMBER .)
    OTHERWISE       reduce using rule 59 (literal -> - NUMBER .)
    NUMBER          reduce using rule 59 (literal -> - NUMBER .)
    STRING          reduce using rule 59 (literal -> - NUMBER .)
    ENDCASE         reduce using rule 59 (literal -> - NUMBER .)
    DO              reduce using rule 59 (literal -> - NUMBER .)
    THEN            reduce using rule 59 (literal -> - NUMBER .)
    ,               reduce using rule 59 (literal -> - NUMBER .)
    ]               reduce using rule 59 (literal -> - NUMBER .)
    )               reduce using rule 59 (literal -> - NUMBER .)
    TO              reduce using rule 59 (literal -> - NUMBER .)
    STEP            reduce using rule 59 (literal -> - NUMBER .)


state 63

    (12) statement -> FOR IDENTIFIER ASSIGN . expression TO expression STEP expression statement_list NEXT
    (13) statement -> FOR IDENTIFIER ASSIGN . expression TO expression statement_list NEXT
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 93
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 64

    (14) statement -> REPEAT statement_list UNTIL . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 94
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 65

    (15) statement -> WHILE expression DO . statement_list ENDWHILE
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 95
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 66

    (16) statement -> CASE OF expression . caselist ENDCASE
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    (30) caselist -> . a_case caselist
    (31) caselist -> . a_case
    (32) a_case -> . OTHERWISE : statement
    (33) a_case -> . constant_label : statement
    (34) constant_label -> . NUMBER
    (35) constant_label -> . STRING
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57
    OTHERWISE       shift and go to state 98
    NUMBER          shift and go to state 100
    STRING          shift and go to state 101

    caselist                       shift and go to state 96
    a_case                         shift and go to state 97
    constant_label                 shift and go to state 99

state 67

    (17) statement -> IF expression THEN . statement_list ELSE statement_list ENDIF
    (18) statement -> IF expression THEN . statement_list ENDIF
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 102
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 68

    (41) arg_list -> expression , . arg_list
    (41) arg_list -> . expression , arg_list
    (42) arg_list -> . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 38
    arg_list                       shift and go to state 103
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 69

    (21) statement -> CONSTANT IDENTIFIER = . literal
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    IDENTIFIER      shift and go to state 104
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    literal                        shift and go to state 105

state 70

    (22) statement -> variable ASSIGN expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    ?               reduce using rule 22 (statement -> variable ASSIGN expression .)
    RETURN          reduce using rule 22 (statement -> variable ASSIGN expression .)
    FOR             reduce using rule 22 (statement -> variable ASSIGN expression .)
    REPEAT          reduce using rule 22 (statement -> variable ASSIGN expression .)
    WHILE           reduce using rule 22 (statement -> variable ASSIGN expression .)
    CASE            reduce using rule 22 (statement -> variable ASSIGN expression .)
    IF              reduce using rule 22 (statement -> variable ASSIGN expression .)
    OUTPUT          reduce using rule 22 (statement -> variable ASSIGN expression .)
    INPUT           reduce using rule 22 (statement -> variable ASSIGN expression .)
    CONSTANT        reduce using rule 22 (statement -> variable ASSIGN expression .)
    CALL            reduce using rule 22 (statement -> variable ASSIGN expression .)
    FUNCTION        reduce using rule 22 (statement -> variable ASSIGN expression .)
    PROCEDURE       reduce using rule 22 (statement -> variable ASSIGN expression .)
    DECLARE         reduce using rule 22 (statement -> variable ASSIGN expression .)
    IDENTIFIER      reduce using rule 22 (statement -> variable ASSIGN expression .)
    $end            reduce using rule 22 (statement -> variable ASSIGN expression .)
    UNTIL           reduce using rule 22 (statement -> variable ASSIGN expression .)
    ENDPROCEDURE    reduce using rule 22 (statement -> variable ASSIGN expression .)
    ENDWHILE        reduce using rule 22 (statement -> variable ASSIGN expression .)
    ELSE            reduce using rule 22 (statement -> variable ASSIGN expression .)
    ENDIF           reduce using rule 22 (statement -> variable ASSIGN expression .)
    ENDFUNCTION     reduce using rule 22 (statement -> variable ASSIGN expression .)
    NEXT            reduce using rule 22 (statement -> variable ASSIGN expression .)
    OTHERWISE       reduce using rule 22 (statement -> variable ASSIGN expression .)
    NUMBER          reduce using rule 22 (statement -> variable ASSIGN expression .)
    STRING          reduce using rule 22 (statement -> variable ASSIGN expression .)
    ENDCASE         reduce using rule 22 (statement -> variable ASSIGN expression .)
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 71

    (24) statement -> CALL IDENTIFIER ( . arg_list )
    (41) arg_list -> . expression , arg_list
    (42) arg_list -> . expression
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    arg_list                       shift and go to state 106
    expression                     shift and go to state 38
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 72

    (25) statement -> FUNCTION IDENTIFIER RETURNS . TYPE statement_list ENDFUNCTION
    TYPE            shift and go to state 107


state 73

    (26) statement -> FUNCTION IDENTIFIER ( . identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (7) identifier_type_list -> . empty
    (8) identifier_type_list -> . identifier_type , identifier_type_list
    (9) identifier_type_list -> . identifier_type
    (4) empty -> .
    (5) identifier_type -> . IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE
    (6) identifier_type -> . IDENTIFIER : TYPE
    )               reduce using rule 4 (empty -> .)
    IDENTIFIER      shift and go to state 46

    identifier_type_list           shift and go to state 108
    empty                          shift and go to state 109
    identifier_type                shift and go to state 110

state 74

    (27) statement -> PROCEDURE IDENTIFIER statement_list . ENDPROCEDURE
    ENDPROCEDURE    shift and go to state 111


state 75

    (28) statement -> PROCEDURE IDENTIFIER ( . identifier_type_list ) statement_list ENDPROCEDURE
    (7) identifier_type_list -> . empty
    (8) identifier_type_list -> . identifier_type , identifier_type_list
    (9) identifier_type_list -> . identifier_type
    (4) empty -> .
    (5) identifier_type -> . IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE
    (6) identifier_type -> . IDENTIFIER : TYPE
    )               reduce using rule 4 (empty -> .)
    IDENTIFIER      shift and go to state 46

    identifier_type_list           shift and go to state 112
    empty                          shift and go to state 109
    identifier_type                shift and go to state 110

state 76

    (5) identifier_type -> IDENTIFIER : . ARRAY [ NUMBER : NUMBER ] OF TYPE
    (6) identifier_type -> IDENTIFIER : . TYPE
    ARRAY           shift and go to state 113
    TYPE            shift and go to state 114


state 77

    (61) variable -> IDENTIFIER [ expression ] .
    ASSIGN          reduce using rule 61 (variable -> IDENTIFIER [ expression ] .)


state 78

    (43) expresssion_operation -> expression AND expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 43 (expresssion_operation -> expression AND expression .)
    OR              reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ?               reduce using rule 43 (expresssion_operation -> expression AND expression .)
    RETURN          reduce using rule 43 (expresssion_operation -> expression AND expression .)
    FOR             reduce using rule 43 (expresssion_operation -> expression AND expression .)
    REPEAT          reduce using rule 43 (expresssion_operation -> expression AND expression .)
    WHILE           reduce using rule 43 (expresssion_operation -> expression AND expression .)
    CASE            reduce using rule 43 (expresssion_operation -> expression AND expression .)
    IF              reduce using rule 43 (expresssion_operation -> expression AND expression .)
    OUTPUT          reduce using rule 43 (expresssion_operation -> expression AND expression .)
    INPUT           reduce using rule 43 (expresssion_operation -> expression AND expression .)
    CONSTANT        reduce using rule 43 (expresssion_operation -> expression AND expression .)
    CALL            reduce using rule 43 (expresssion_operation -> expression AND expression .)
    FUNCTION        reduce using rule 43 (expresssion_operation -> expression AND expression .)
    PROCEDURE       reduce using rule 43 (expresssion_operation -> expression AND expression .)
    DECLARE         reduce using rule 43 (expresssion_operation -> expression AND expression .)
    IDENTIFIER      reduce using rule 43 (expresssion_operation -> expression AND expression .)
    $end            reduce using rule 43 (expresssion_operation -> expression AND expression .)
    UNTIL           reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ENDPROCEDURE    reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ENDWHILE        reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ELSE            reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ENDIF           reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ENDFUNCTION     reduce using rule 43 (expresssion_operation -> expression AND expression .)
    NEXT            reduce using rule 43 (expresssion_operation -> expression AND expression .)
    OTHERWISE       reduce using rule 43 (expresssion_operation -> expression AND expression .)
    NUMBER          reduce using rule 43 (expresssion_operation -> expression AND expression .)
    STRING          reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ENDCASE         reduce using rule 43 (expresssion_operation -> expression AND expression .)
    DO              reduce using rule 43 (expresssion_operation -> expression AND expression .)
    THEN            reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ,               reduce using rule 43 (expresssion_operation -> expression AND expression .)
    ]               reduce using rule 43 (expresssion_operation -> expression AND expression .)
    )               reduce using rule 43 (expresssion_operation -> expression AND expression .)
    TO              reduce using rule 43 (expresssion_operation -> expression AND expression .)
    STEP            reduce using rule 43 (expresssion_operation -> expression AND expression .)
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 79

    (44) expresssion_operation -> expression OR expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    OR              reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ?               reduce using rule 44 (expresssion_operation -> expression OR expression .)
    RETURN          reduce using rule 44 (expresssion_operation -> expression OR expression .)
    FOR             reduce using rule 44 (expresssion_operation -> expression OR expression .)
    REPEAT          reduce using rule 44 (expresssion_operation -> expression OR expression .)
    WHILE           reduce using rule 44 (expresssion_operation -> expression OR expression .)
    CASE            reduce using rule 44 (expresssion_operation -> expression OR expression .)
    IF              reduce using rule 44 (expresssion_operation -> expression OR expression .)
    OUTPUT          reduce using rule 44 (expresssion_operation -> expression OR expression .)
    INPUT           reduce using rule 44 (expresssion_operation -> expression OR expression .)
    CONSTANT        reduce using rule 44 (expresssion_operation -> expression OR expression .)
    CALL            reduce using rule 44 (expresssion_operation -> expression OR expression .)
    FUNCTION        reduce using rule 44 (expresssion_operation -> expression OR expression .)
    PROCEDURE       reduce using rule 44 (expresssion_operation -> expression OR expression .)
    DECLARE         reduce using rule 44 (expresssion_operation -> expression OR expression .)
    IDENTIFIER      reduce using rule 44 (expresssion_operation -> expression OR expression .)
    $end            reduce using rule 44 (expresssion_operation -> expression OR expression .)
    UNTIL           reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ENDPROCEDURE    reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ENDWHILE        reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ELSE            reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ENDIF           reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ENDFUNCTION     reduce using rule 44 (expresssion_operation -> expression OR expression .)
    NEXT            reduce using rule 44 (expresssion_operation -> expression OR expression .)
    OTHERWISE       reduce using rule 44 (expresssion_operation -> expression OR expression .)
    NUMBER          reduce using rule 44 (expresssion_operation -> expression OR expression .)
    STRING          reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ENDCASE         reduce using rule 44 (expresssion_operation -> expression OR expression .)
    DO              reduce using rule 44 (expresssion_operation -> expression OR expression .)
    THEN            reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ,               reduce using rule 44 (expresssion_operation -> expression OR expression .)
    ]               reduce using rule 44 (expresssion_operation -> expression OR expression .)
    )               reduce using rule 44 (expresssion_operation -> expression OR expression .)
    TO              reduce using rule 44 (expresssion_operation -> expression OR expression .)
    STEP            reduce using rule 44 (expresssion_operation -> expression OR expression .)
    AND             shift and go to state 48
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 80

    (45) expresssion_operation -> expression SMALLER expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    OR              reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    SMALLER         reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    BIGGER          reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    NOTEQUAL        reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    EQUAL           reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ?               reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    RETURN          reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    FOR             reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    REPEAT          reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    WHILE           reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    CASE            reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    IF              reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    OUTPUT          reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    INPUT           reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    CONSTANT        reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    CALL            reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    FUNCTION        reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    PROCEDURE       reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    DECLARE         reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    IDENTIFIER      reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    $end            reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    UNTIL           reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ENDPROCEDURE    reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ENDWHILE        reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ELSE            reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ENDIF           reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ENDFUNCTION     reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    NEXT            reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    OTHERWISE       reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    NUMBER          reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    STRING          reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ENDCASE         reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    DO              reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    THEN            reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ,               reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    ]               reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    )               reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    TO              reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    STEP            reduce using rule 45 (expresssion_operation -> expression SMALLER expression .)
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 81

    (46) expresssion_operation -> expression BIGGER expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    OR              reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    SMALLER         reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    BIGGER          reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    NOTEQUAL        reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    EQUAL           reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ?               reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    RETURN          reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    FOR             reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    REPEAT          reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    WHILE           reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    CASE            reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    IF              reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    OUTPUT          reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    INPUT           reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    CONSTANT        reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    CALL            reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    FUNCTION        reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    PROCEDURE       reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    DECLARE         reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    IDENTIFIER      reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    $end            reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    UNTIL           reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ENDPROCEDURE    reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ENDWHILE        reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ELSE            reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ENDIF           reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ENDFUNCTION     reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    NEXT            reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    OTHERWISE       reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    NUMBER          reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    STRING          reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ENDCASE         reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    DO              reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    THEN            reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ,               reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    ]               reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    )               reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    TO              reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    STEP            reduce using rule 46 (expresssion_operation -> expression BIGGER expression .)
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 82

    (47) expresssion_operation -> expression NOTEQUAL expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    OR              reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    NOTEQUAL        reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    EQUAL           reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ?               reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    RETURN          reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    FOR             reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    REPEAT          reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    WHILE           reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    CASE            reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    IF              reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    OUTPUT          reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    INPUT           reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    CONSTANT        reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    CALL            reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    FUNCTION        reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    PROCEDURE       reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    DECLARE         reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    IDENTIFIER      reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    $end            reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    UNTIL           reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ENDPROCEDURE    reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ENDWHILE        reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ELSE            reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ENDIF           reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ENDFUNCTION     reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    NEXT            reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    OTHERWISE       reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    NUMBER          reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    STRING          reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ENDCASE         reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    DO              reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    THEN            reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ,               reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    ]               reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    )               reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    TO              reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    STEP            reduce using rule 47 (expresssion_operation -> expression NOTEQUAL expression .)
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 83

    (48) expresssion_operation -> expression EQUAL expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    OR              reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    NOTEQUAL        reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    EQUAL           reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ?               reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    RETURN          reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    FOR             reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    REPEAT          reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    WHILE           reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    CASE            reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    IF              reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    OUTPUT          reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    INPUT           reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    CONSTANT        reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    CALL            reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    FUNCTION        reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    PROCEDURE       reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    DECLARE         reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    IDENTIFIER      reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    $end            reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    UNTIL           reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ENDPROCEDURE    reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ENDWHILE        reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ELSE            reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ENDIF           reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ENDFUNCTION     reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    NEXT            reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    OTHERWISE       reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    NUMBER          reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    STRING          reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ENDCASE         reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    DO              reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    THEN            reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ,               reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    ]               reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    )               reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    TO              reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    STEP            reduce using rule 48 (expresssion_operation -> expression EQUAL expression .)
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 84

    (49) expresssion_operation -> expression * expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 49 (expresssion_operation -> expression * expression .)
    OR              reduce using rule 49 (expresssion_operation -> expression * expression .)
    SMALLER         reduce using rule 49 (expresssion_operation -> expression * expression .)
    BIGGER          reduce using rule 49 (expresssion_operation -> expression * expression .)
    NOTEQUAL        reduce using rule 49 (expresssion_operation -> expression * expression .)
    EQUAL           reduce using rule 49 (expresssion_operation -> expression * expression .)
    *               reduce using rule 49 (expresssion_operation -> expression * expression .)
    /               reduce using rule 49 (expresssion_operation -> expression * expression .)
    +               reduce using rule 49 (expresssion_operation -> expression * expression .)
    -               reduce using rule 49 (expresssion_operation -> expression * expression .)
    ?               reduce using rule 49 (expresssion_operation -> expression * expression .)
    RETURN          reduce using rule 49 (expresssion_operation -> expression * expression .)
    FOR             reduce using rule 49 (expresssion_operation -> expression * expression .)
    REPEAT          reduce using rule 49 (expresssion_operation -> expression * expression .)
    WHILE           reduce using rule 49 (expresssion_operation -> expression * expression .)
    CASE            reduce using rule 49 (expresssion_operation -> expression * expression .)
    IF              reduce using rule 49 (expresssion_operation -> expression * expression .)
    OUTPUT          reduce using rule 49 (expresssion_operation -> expression * expression .)
    INPUT           reduce using rule 49 (expresssion_operation -> expression * expression .)
    CONSTANT        reduce using rule 49 (expresssion_operation -> expression * expression .)
    CALL            reduce using rule 49 (expresssion_operation -> expression * expression .)
    FUNCTION        reduce using rule 49 (expresssion_operation -> expression * expression .)
    PROCEDURE       reduce using rule 49 (expresssion_operation -> expression * expression .)
    DECLARE         reduce using rule 49 (expresssion_operation -> expression * expression .)
    IDENTIFIER      reduce using rule 49 (expresssion_operation -> expression * expression .)
    $end            reduce using rule 49 (expresssion_operation -> expression * expression .)
    UNTIL           reduce using rule 49 (expresssion_operation -> expression * expression .)
    ENDPROCEDURE    reduce using rule 49 (expresssion_operation -> expression * expression .)
    ENDWHILE        reduce using rule 49 (expresssion_operation -> expression * expression .)
    ELSE            reduce using rule 49 (expresssion_operation -> expression * expression .)
    ENDIF           reduce using rule 49 (expresssion_operation -> expression * expression .)
    ENDFUNCTION     reduce using rule 49 (expresssion_operation -> expression * expression .)
    NEXT            reduce using rule 49 (expresssion_operation -> expression * expression .)
    OTHERWISE       reduce using rule 49 (expresssion_operation -> expression * expression .)
    NUMBER          reduce using rule 49 (expresssion_operation -> expression * expression .)
    STRING          reduce using rule 49 (expresssion_operation -> expression * expression .)
    ENDCASE         reduce using rule 49 (expresssion_operation -> expression * expression .)
    DO              reduce using rule 49 (expresssion_operation -> expression * expression .)
    THEN            reduce using rule 49 (expresssion_operation -> expression * expression .)
    ,               reduce using rule 49 (expresssion_operation -> expression * expression .)
    ]               reduce using rule 49 (expresssion_operation -> expression * expression .)
    )               reduce using rule 49 (expresssion_operation -> expression * expression .)
    TO              reduce using rule 49 (expresssion_operation -> expression * expression .)
    STEP            reduce using rule 49 (expresssion_operation -> expression * expression .)


state 85

    (50) expresssion_operation -> expression / expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 50 (expresssion_operation -> expression / expression .)
    OR              reduce using rule 50 (expresssion_operation -> expression / expression .)
    SMALLER         reduce using rule 50 (expresssion_operation -> expression / expression .)
    BIGGER          reduce using rule 50 (expresssion_operation -> expression / expression .)
    NOTEQUAL        reduce using rule 50 (expresssion_operation -> expression / expression .)
    EQUAL           reduce using rule 50 (expresssion_operation -> expression / expression .)
    *               reduce using rule 50 (expresssion_operation -> expression / expression .)
    /               reduce using rule 50 (expresssion_operation -> expression / expression .)
    +               reduce using rule 50 (expresssion_operation -> expression / expression .)
    -               reduce using rule 50 (expresssion_operation -> expression / expression .)
    ?               reduce using rule 50 (expresssion_operation -> expression / expression .)
    RETURN          reduce using rule 50 (expresssion_operation -> expression / expression .)
    FOR             reduce using rule 50 (expresssion_operation -> expression / expression .)
    REPEAT          reduce using rule 50 (expresssion_operation -> expression / expression .)
    WHILE           reduce using rule 50 (expresssion_operation -> expression / expression .)
    CASE            reduce using rule 50 (expresssion_operation -> expression / expression .)
    IF              reduce using rule 50 (expresssion_operation -> expression / expression .)
    OUTPUT          reduce using rule 50 (expresssion_operation -> expression / expression .)
    INPUT           reduce using rule 50 (expresssion_operation -> expression / expression .)
    CONSTANT        reduce using rule 50 (expresssion_operation -> expression / expression .)
    CALL            reduce using rule 50 (expresssion_operation -> expression / expression .)
    FUNCTION        reduce using rule 50 (expresssion_operation -> expression / expression .)
    PROCEDURE       reduce using rule 50 (expresssion_operation -> expression / expression .)
    DECLARE         reduce using rule 50 (expresssion_operation -> expression / expression .)
    IDENTIFIER      reduce using rule 50 (expresssion_operation -> expression / expression .)
    $end            reduce using rule 50 (expresssion_operation -> expression / expression .)
    UNTIL           reduce using rule 50 (expresssion_operation -> expression / expression .)
    ENDPROCEDURE    reduce using rule 50 (expresssion_operation -> expression / expression .)
    ENDWHILE        reduce using rule 50 (expresssion_operation -> expression / expression .)
    ELSE            reduce using rule 50 (expresssion_operation -> expression / expression .)
    ENDIF           reduce using rule 50 (expresssion_operation -> expression / expression .)
    ENDFUNCTION     reduce using rule 50 (expresssion_operation -> expression / expression .)
    NEXT            reduce using rule 50 (expresssion_operation -> expression / expression .)
    OTHERWISE       reduce using rule 50 (expresssion_operation -> expression / expression .)
    NUMBER          reduce using rule 50 (expresssion_operation -> expression / expression .)
    STRING          reduce using rule 50 (expresssion_operation -> expression / expression .)
    ENDCASE         reduce using rule 50 (expresssion_operation -> expression / expression .)
    DO              reduce using rule 50 (expresssion_operation -> expression / expression .)
    THEN            reduce using rule 50 (expresssion_operation -> expression / expression .)
    ,               reduce using rule 50 (expresssion_operation -> expression / expression .)
    ]               reduce using rule 50 (expresssion_operation -> expression / expression .)
    )               reduce using rule 50 (expresssion_operation -> expression / expression .)
    TO              reduce using rule 50 (expresssion_operation -> expression / expression .)
    STEP            reduce using rule 50 (expresssion_operation -> expression / expression .)


state 86

    (51) expresssion_operation -> expression + expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 51 (expresssion_operation -> expression + expression .)
    OR              reduce using rule 51 (expresssion_operation -> expression + expression .)
    SMALLER         reduce using rule 51 (expresssion_operation -> expression + expression .)
    BIGGER          reduce using rule 51 (expresssion_operation -> expression + expression .)
    NOTEQUAL        reduce using rule 51 (expresssion_operation -> expression + expression .)
    EQUAL           reduce using rule 51 (expresssion_operation -> expression + expression .)
    +               reduce using rule 51 (expresssion_operation -> expression + expression .)
    -               reduce using rule 51 (expresssion_operation -> expression + expression .)
    ?               reduce using rule 51 (expresssion_operation -> expression + expression .)
    RETURN          reduce using rule 51 (expresssion_operation -> expression + expression .)
    FOR             reduce using rule 51 (expresssion_operation -> expression + expression .)
    REPEAT          reduce using rule 51 (expresssion_operation -> expression + expression .)
    WHILE           reduce using rule 51 (expresssion_operation -> expression + expression .)
    CASE            reduce using rule 51 (expresssion_operation -> expression + expression .)
    IF              reduce using rule 51 (expresssion_operation -> expression + expression .)
    OUTPUT          reduce using rule 51 (expresssion_operation -> expression + expression .)
    INPUT           reduce using rule 51 (expresssion_operation -> expression + expression .)
    CONSTANT        reduce using rule 51 (expresssion_operation -> expression + expression .)
    CALL            reduce using rule 51 (expresssion_operation -> expression + expression .)
    FUNCTION        reduce using rule 51 (expresssion_operation -> expression + expression .)
    PROCEDURE       reduce using rule 51 (expresssion_operation -> expression + expression .)
    DECLARE         reduce using rule 51 (expresssion_operation -> expression + expression .)
    IDENTIFIER      reduce using rule 51 (expresssion_operation -> expression + expression .)
    $end            reduce using rule 51 (expresssion_operation -> expression + expression .)
    UNTIL           reduce using rule 51 (expresssion_operation -> expression + expression .)
    ENDPROCEDURE    reduce using rule 51 (expresssion_operation -> expression + expression .)
    ENDWHILE        reduce using rule 51 (expresssion_operation -> expression + expression .)
    ELSE            reduce using rule 51 (expresssion_operation -> expression + expression .)
    ENDIF           reduce using rule 51 (expresssion_operation -> expression + expression .)
    ENDFUNCTION     reduce using rule 51 (expresssion_operation -> expression + expression .)
    NEXT            reduce using rule 51 (expresssion_operation -> expression + expression .)
    OTHERWISE       reduce using rule 51 (expresssion_operation -> expression + expression .)
    NUMBER          reduce using rule 51 (expresssion_operation -> expression + expression .)
    STRING          reduce using rule 51 (expresssion_operation -> expression + expression .)
    ENDCASE         reduce using rule 51 (expresssion_operation -> expression + expression .)
    DO              reduce using rule 51 (expresssion_operation -> expression + expression .)
    THEN            reduce using rule 51 (expresssion_operation -> expression + expression .)
    ,               reduce using rule 51 (expresssion_operation -> expression + expression .)
    ]               reduce using rule 51 (expresssion_operation -> expression + expression .)
    )               reduce using rule 51 (expresssion_operation -> expression + expression .)
    TO              reduce using rule 51 (expresssion_operation -> expression + expression .)
    STEP            reduce using rule 51 (expresssion_operation -> expression + expression .)
    *               shift and go to state 54
    /               shift and go to state 55


state 87

    (52) expresssion_operation -> expression - expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    AND             reduce using rule 52 (expresssion_operation -> expression - expression .)
    OR              reduce using rule 52 (expresssion_operation -> expression - expression .)
    SMALLER         reduce using rule 52 (expresssion_operation -> expression - expression .)
    BIGGER          reduce using rule 52 (expresssion_operation -> expression - expression .)
    NOTEQUAL        reduce using rule 52 (expresssion_operation -> expression - expression .)
    EQUAL           reduce using rule 52 (expresssion_operation -> expression - expression .)
    +               reduce using rule 52 (expresssion_operation -> expression - expression .)
    -               reduce using rule 52 (expresssion_operation -> expression - expression .)
    ?               reduce using rule 52 (expresssion_operation -> expression - expression .)
    RETURN          reduce using rule 52 (expresssion_operation -> expression - expression .)
    FOR             reduce using rule 52 (expresssion_operation -> expression - expression .)
    REPEAT          reduce using rule 52 (expresssion_operation -> expression - expression .)
    WHILE           reduce using rule 52 (expresssion_operation -> expression - expression .)
    CASE            reduce using rule 52 (expresssion_operation -> expression - expression .)
    IF              reduce using rule 52 (expresssion_operation -> expression - expression .)
    OUTPUT          reduce using rule 52 (expresssion_operation -> expression - expression .)
    INPUT           reduce using rule 52 (expresssion_operation -> expression - expression .)
    CONSTANT        reduce using rule 52 (expresssion_operation -> expression - expression .)
    CALL            reduce using rule 52 (expresssion_operation -> expression - expression .)
    FUNCTION        reduce using rule 52 (expresssion_operation -> expression - expression .)
    PROCEDURE       reduce using rule 52 (expresssion_operation -> expression - expression .)
    DECLARE         reduce using rule 52 (expresssion_operation -> expression - expression .)
    IDENTIFIER      reduce using rule 52 (expresssion_operation -> expression - expression .)
    $end            reduce using rule 52 (expresssion_operation -> expression - expression .)
    UNTIL           reduce using rule 52 (expresssion_operation -> expression - expression .)
    ENDPROCEDURE    reduce using rule 52 (expresssion_operation -> expression - expression .)
    ENDWHILE        reduce using rule 52 (expresssion_operation -> expression - expression .)
    ELSE            reduce using rule 52 (expresssion_operation -> expression - expression .)
    ENDIF           reduce using rule 52 (expresssion_operation -> expression - expression .)
    ENDFUNCTION     reduce using rule 52 (expresssion_operation -> expression - expression .)
    NEXT            reduce using rule 52 (expresssion_operation -> expression - expression .)
    OTHERWISE       reduce using rule 52 (expresssion_operation -> expression - expression .)
    NUMBER          reduce using rule 52 (expresssion_operation -> expression - expression .)
    STRING          reduce using rule 52 (expresssion_operation -> expression - expression .)
    ENDCASE         reduce using rule 52 (expresssion_operation -> expression - expression .)
    DO              reduce using rule 52 (expresssion_operation -> expression - expression .)
    THEN            reduce using rule 52 (expresssion_operation -> expression - expression .)
    ,               reduce using rule 52 (expresssion_operation -> expression - expression .)
    ]               reduce using rule 52 (expresssion_operation -> expression - expression .)
    )               reduce using rule 52 (expresssion_operation -> expression - expression .)
    TO              reduce using rule 52 (expresssion_operation -> expression - expression .)
    STEP            reduce using rule 52 (expresssion_operation -> expression - expression .)
    *               shift and go to state 54
    /               shift and go to state 55


state 88

    (37) expression -> IDENTIFIER ( ) .
    AND             reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    OR              reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    SMALLER         reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    BIGGER          reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    NOTEQUAL        reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    EQUAL           reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    *               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    /               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    +               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    -               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ?               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    RETURN          reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    FOR             reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    REPEAT          reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    WHILE           reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    CASE            reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    IF              reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    OUTPUT          reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    INPUT           reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    CONSTANT        reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    CALL            reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    FUNCTION        reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    PROCEDURE       reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    DECLARE         reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    IDENTIFIER      reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    $end            reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    UNTIL           reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ENDPROCEDURE    reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ENDWHILE        reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ELSE            reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ENDIF           reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ENDFUNCTION     reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    NEXT            reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    OTHERWISE       reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    NUMBER          reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    STRING          reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ENDCASE         reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    DO              reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    THEN            reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ,               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    ]               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    )               reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    TO              reduce using rule 37 (expression -> IDENTIFIER ( ) .)
    STEP            reduce using rule 37 (expression -> IDENTIFIER ( ) .)


state 89

    (38) expression -> IDENTIFIER ( arg_list . )
    )               shift and go to state 115


state 90

    (54) literal -> IDENTIFIER [ expression . ]
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    ]               shift and go to state 116
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 91

    (40) expression -> ( expression ) .
    AND             reduce using rule 40 (expression -> ( expression ) .)
    OR              reduce using rule 40 (expression -> ( expression ) .)
    SMALLER         reduce using rule 40 (expression -> ( expression ) .)
    BIGGER          reduce using rule 40 (expression -> ( expression ) .)
    NOTEQUAL        reduce using rule 40 (expression -> ( expression ) .)
    EQUAL           reduce using rule 40 (expression -> ( expression ) .)
    *               reduce using rule 40 (expression -> ( expression ) .)
    /               reduce using rule 40 (expression -> ( expression ) .)
    +               reduce using rule 40 (expression -> ( expression ) .)
    -               reduce using rule 40 (expression -> ( expression ) .)
    ?               reduce using rule 40 (expression -> ( expression ) .)
    RETURN          reduce using rule 40 (expression -> ( expression ) .)
    FOR             reduce using rule 40 (expression -> ( expression ) .)
    REPEAT          reduce using rule 40 (expression -> ( expression ) .)
    WHILE           reduce using rule 40 (expression -> ( expression ) .)
    CASE            reduce using rule 40 (expression -> ( expression ) .)
    IF              reduce using rule 40 (expression -> ( expression ) .)
    OUTPUT          reduce using rule 40 (expression -> ( expression ) .)
    INPUT           reduce using rule 40 (expression -> ( expression ) .)
    CONSTANT        reduce using rule 40 (expression -> ( expression ) .)
    CALL            reduce using rule 40 (expression -> ( expression ) .)
    FUNCTION        reduce using rule 40 (expression -> ( expression ) .)
    PROCEDURE       reduce using rule 40 (expression -> ( expression ) .)
    DECLARE         reduce using rule 40 (expression -> ( expression ) .)
    IDENTIFIER      reduce using rule 40 (expression -> ( expression ) .)
    $end            reduce using rule 40 (expression -> ( expression ) .)
    UNTIL           reduce using rule 40 (expression -> ( expression ) .)
    ENDPROCEDURE    reduce using rule 40 (expression -> ( expression ) .)
    ENDWHILE        reduce using rule 40 (expression -> ( expression ) .)
    ELSE            reduce using rule 40 (expression -> ( expression ) .)
    ENDIF           reduce using rule 40 (expression -> ( expression ) .)
    ENDFUNCTION     reduce using rule 40 (expression -> ( expression ) .)
    NEXT            reduce using rule 40 (expression -> ( expression ) .)
    OTHERWISE       reduce using rule 40 (expression -> ( expression ) .)
    NUMBER          reduce using rule 40 (expression -> ( expression ) .)
    STRING          reduce using rule 40 (expression -> ( expression ) .)
    ENDCASE         reduce using rule 40 (expression -> ( expression ) .)
    DO              reduce using rule 40 (expression -> ( expression ) .)
    THEN            reduce using rule 40 (expression -> ( expression ) .)
    ,               reduce using rule 40 (expression -> ( expression ) .)
    ]               reduce using rule 40 (expression -> ( expression ) .)
    )               reduce using rule 40 (expression -> ( expression ) .)
    TO              reduce using rule 40 (expression -> ( expression ) .)
    STEP            reduce using rule 40 (expression -> ( expression ) .)


state 92

    (57) literal -> NUMBER . NUMBER .
    AND             reduce using rule 57 (literal -> NUMBER . NUMBER .)
    OR              reduce using rule 57 (literal -> NUMBER . NUMBER .)
    SMALLER         reduce using rule 57 (literal -> NUMBER . NUMBER .)
    BIGGER          reduce using rule 57 (literal -> NUMBER . NUMBER .)
    NOTEQUAL        reduce using rule 57 (literal -> NUMBER . NUMBER .)
    EQUAL           reduce using rule 57 (literal -> NUMBER . NUMBER .)
    *               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    /               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    +               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    -               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ?               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    RETURN          reduce using rule 57 (literal -> NUMBER . NUMBER .)
    FOR             reduce using rule 57 (literal -> NUMBER . NUMBER .)
    REPEAT          reduce using rule 57 (literal -> NUMBER . NUMBER .)
    WHILE           reduce using rule 57 (literal -> NUMBER . NUMBER .)
    CASE            reduce using rule 57 (literal -> NUMBER . NUMBER .)
    IF              reduce using rule 57 (literal -> NUMBER . NUMBER .)
    OUTPUT          reduce using rule 57 (literal -> NUMBER . NUMBER .)
    INPUT           reduce using rule 57 (literal -> NUMBER . NUMBER .)
    CONSTANT        reduce using rule 57 (literal -> NUMBER . NUMBER .)
    CALL            reduce using rule 57 (literal -> NUMBER . NUMBER .)
    FUNCTION        reduce using rule 57 (literal -> NUMBER . NUMBER .)
    PROCEDURE       reduce using rule 57 (literal -> NUMBER . NUMBER .)
    DECLARE         reduce using rule 57 (literal -> NUMBER . NUMBER .)
    IDENTIFIER      reduce using rule 57 (literal -> NUMBER . NUMBER .)
    $end            reduce using rule 57 (literal -> NUMBER . NUMBER .)
    UNTIL           reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ENDPROCEDURE    reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ENDWHILE        reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ELSE            reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ENDIF           reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ENDFUNCTION     reduce using rule 57 (literal -> NUMBER . NUMBER .)
    NEXT            reduce using rule 57 (literal -> NUMBER . NUMBER .)
    OTHERWISE       reduce using rule 57 (literal -> NUMBER . NUMBER .)
    NUMBER          reduce using rule 57 (literal -> NUMBER . NUMBER .)
    STRING          reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ENDCASE         reduce using rule 57 (literal -> NUMBER . NUMBER .)
    DO              reduce using rule 57 (literal -> NUMBER . NUMBER .)
    THEN            reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ,               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    ]               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    )               reduce using rule 57 (literal -> NUMBER . NUMBER .)
    TO              reduce using rule 57 (literal -> NUMBER . NUMBER .)
    STEP            reduce using rule 57 (literal -> NUMBER . NUMBER .)


state 93

    (12) statement -> FOR IDENTIFIER ASSIGN expression . TO expression STEP expression statement_list NEXT
    (13) statement -> FOR IDENTIFIER ASSIGN expression . TO expression statement_list NEXT
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    TO              shift and go to state 117
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 94

    (14) statement -> REPEAT statement_list UNTIL expression .
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    ?               reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    RETURN          reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    FOR             reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    REPEAT          reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    WHILE           reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    CASE            reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    IF              reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    OUTPUT          reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    INPUT           reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    CONSTANT        reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    CALL            reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    FUNCTION        reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    PROCEDURE       reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    DECLARE         reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    IDENTIFIER      reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    $end            reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    UNTIL           reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    ENDPROCEDURE    reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    ENDWHILE        reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    ELSE            reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    ENDIF           reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    ENDFUNCTION     reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    NEXT            reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    OTHERWISE       reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    NUMBER          reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    STRING          reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    ENDCASE         reduce using rule 14 (statement -> REPEAT statement_list UNTIL expression .)
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57


state 95

    (15) statement -> WHILE expression DO statement_list . ENDWHILE
    ENDWHILE        shift and go to state 118


state 96

    (16) statement -> CASE OF expression caselist . ENDCASE
    ENDCASE         shift and go to state 119


state 97

    (30) caselist -> a_case . caselist
    (31) caselist -> a_case .
    (30) caselist -> . a_case caselist
    (31) caselist -> . a_case
    (32) a_case -> . OTHERWISE : statement
    (33) a_case -> . constant_label : statement
    (34) constant_label -> . NUMBER
    (35) constant_label -> . STRING
    ENDCASE         reduce using rule 31 (caselist -> a_case .)
    OTHERWISE       shift and go to state 98
    NUMBER          shift and go to state 100
    STRING          shift and go to state 101

    a_case                         shift and go to state 97
    caselist                       shift and go to state 120
    constant_label                 shift and go to state 99

state 98

    (32) a_case -> OTHERWISE . : statement
    :               shift and go to state 121


state 99

    (33) a_case -> constant_label . : statement
    :               shift and go to state 122


state 100

    (34) constant_label -> NUMBER .
    :               reduce using rule 34 (constant_label -> NUMBER .)


state 101

    (35) constant_label -> STRING .
    :               reduce using rule 35 (constant_label -> STRING .)


state 102

    (17) statement -> IF expression THEN statement_list . ELSE statement_list ENDIF
    (18) statement -> IF expression THEN statement_list . ENDIF
    ELSE            shift and go to state 123
    ENDIF           shift and go to state 124


state 103

    (41) arg_list -> expression , arg_list .
    ?               reduce using rule 41 (arg_list -> expression , arg_list .)
    RETURN          reduce using rule 41 (arg_list -> expression , arg_list .)
    FOR             reduce using rule 41 (arg_list -> expression , arg_list .)
    REPEAT          reduce using rule 41 (arg_list -> expression , arg_list .)
    WHILE           reduce using rule 41 (arg_list -> expression , arg_list .)
    CASE            reduce using rule 41 (arg_list -> expression , arg_list .)
    IF              reduce using rule 41 (arg_list -> expression , arg_list .)
    OUTPUT          reduce using rule 41 (arg_list -> expression , arg_list .)
    INPUT           reduce using rule 41 (arg_list -> expression , arg_list .)
    CONSTANT        reduce using rule 41 (arg_list -> expression , arg_list .)
    CALL            reduce using rule 41 (arg_list -> expression , arg_list .)
    FUNCTION        reduce using rule 41 (arg_list -> expression , arg_list .)
    PROCEDURE       reduce using rule 41 (arg_list -> expression , arg_list .)
    DECLARE         reduce using rule 41 (arg_list -> expression , arg_list .)
    IDENTIFIER      reduce using rule 41 (arg_list -> expression , arg_list .)
    $end            reduce using rule 41 (arg_list -> expression , arg_list .)
    UNTIL           reduce using rule 41 (arg_list -> expression , arg_list .)
    ENDPROCEDURE    reduce using rule 41 (arg_list -> expression , arg_list .)
    ENDWHILE        reduce using rule 41 (arg_list -> expression , arg_list .)
    ELSE            reduce using rule 41 (arg_list -> expression , arg_list .)
    ENDIF           reduce using rule 41 (arg_list -> expression , arg_list .)
    ENDFUNCTION     reduce using rule 41 (arg_list -> expression , arg_list .)
    NEXT            reduce using rule 41 (arg_list -> expression , arg_list .)
    OTHERWISE       reduce using rule 41 (arg_list -> expression , arg_list .)
    NUMBER          reduce using rule 41 (arg_list -> expression , arg_list .)
    STRING          reduce using rule 41 (arg_list -> expression , arg_list .)
    ENDCASE         reduce using rule 41 (arg_list -> expression , arg_list .)
    )               reduce using rule 41 (arg_list -> expression , arg_list .)


state 104

    (53) literal -> IDENTIFIER .
    (54) literal -> IDENTIFIER . [ expression ]
    ?               reduce using rule 53 (literal -> IDENTIFIER .)
    RETURN          reduce using rule 53 (literal -> IDENTIFIER .)
    FOR             reduce using rule 53 (literal -> IDENTIFIER .)
    REPEAT          reduce using rule 53 (literal -> IDENTIFIER .)
    WHILE           reduce using rule 53 (literal -> IDENTIFIER .)
    CASE            reduce using rule 53 (literal -> IDENTIFIER .)
    IF              reduce using rule 53 (literal -> IDENTIFIER .)
    OUTPUT          reduce using rule 53 (literal -> IDENTIFIER .)
    INPUT           reduce using rule 53 (literal -> IDENTIFIER .)
    CONSTANT        reduce using rule 53 (literal -> IDENTIFIER .)
    CALL            reduce using rule 53 (literal -> IDENTIFIER .)
    FUNCTION        reduce using rule 53 (literal -> IDENTIFIER .)
    PROCEDURE       reduce using rule 53 (literal -> IDENTIFIER .)
    DECLARE         reduce using rule 53 (literal -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 53 (literal -> IDENTIFIER .)
    $end            reduce using rule 53 (literal -> IDENTIFIER .)
    UNTIL           reduce using rule 53 (literal -> IDENTIFIER .)
    ENDPROCEDURE    reduce using rule 53 (literal -> IDENTIFIER .)
    ENDWHILE        reduce using rule 53 (literal -> IDENTIFIER .)
    ELSE            reduce using rule 53 (literal -> IDENTIFIER .)
    ENDIF           reduce using rule 53 (literal -> IDENTIFIER .)
    ENDFUNCTION     reduce using rule 53 (literal -> IDENTIFIER .)
    NEXT            reduce using rule 53 (literal -> IDENTIFIER .)
    OTHERWISE       reduce using rule 53 (literal -> IDENTIFIER .)
    NUMBER          reduce using rule 53 (literal -> IDENTIFIER .)
    STRING          reduce using rule 53 (literal -> IDENTIFIER .)
    ENDCASE         reduce using rule 53 (literal -> IDENTIFIER .)
    [               shift and go to state 59


state 105

    (21) statement -> CONSTANT IDENTIFIER = literal .
    ?               reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    RETURN          reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    FOR             reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    REPEAT          reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    WHILE           reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    CASE            reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    IF              reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    OUTPUT          reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    INPUT           reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    CONSTANT        reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    CALL            reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    FUNCTION        reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    PROCEDURE       reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    DECLARE         reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    IDENTIFIER      reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    $end            reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    UNTIL           reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    ENDPROCEDURE    reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    ENDWHILE        reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    ELSE            reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    ENDIF           reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    ENDFUNCTION     reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    NEXT            reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    OTHERWISE       reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    NUMBER          reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    STRING          reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)
    ENDCASE         reduce using rule 21 (statement -> CONSTANT IDENTIFIER = literal .)


state 106

    (24) statement -> CALL IDENTIFIER ( arg_list . )
    )               shift and go to state 125


state 107

    (25) statement -> FUNCTION IDENTIFIER RETURNS TYPE . statement_list ENDFUNCTION
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 126
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 108

    (26) statement -> FUNCTION IDENTIFIER ( identifier_type_list . ) RETURNS TYPE statement_list ENDFUNCTION
    )               shift and go to state 127


state 109

    (7) identifier_type_list -> empty .
    )               reduce using rule 7 (identifier_type_list -> empty .)


state 110

    (8) identifier_type_list -> identifier_type . , identifier_type_list
    (9) identifier_type_list -> identifier_type .
    ,               shift and go to state 128
    )               reduce using rule 9 (identifier_type_list -> identifier_type .)


state 111

    (27) statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .
    ?               reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    RETURN          reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    FOR             reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    REPEAT          reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    WHILE           reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    CASE            reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    IF              reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    OUTPUT          reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    INPUT           reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    CONSTANT        reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    CALL            reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    FUNCTION        reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    PROCEDURE       reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    DECLARE         reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    IDENTIFIER      reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    $end            reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    UNTIL           reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    ENDPROCEDURE    reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    ENDWHILE        reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    ELSE            reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    ENDIF           reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    ENDFUNCTION     reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    NEXT            reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    OTHERWISE       reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    NUMBER          reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    STRING          reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)
    ENDCASE         reduce using rule 27 (statement -> PROCEDURE IDENTIFIER statement_list ENDPROCEDURE .)


state 112

    (28) statement -> PROCEDURE IDENTIFIER ( identifier_type_list . ) statement_list ENDPROCEDURE
    )               shift and go to state 129


state 113

    (5) identifier_type -> IDENTIFIER : ARRAY . [ NUMBER : NUMBER ] OF TYPE
    [               shift and go to state 130


state 114

    (6) identifier_type -> IDENTIFIER : TYPE .
    ?               reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    RETURN          reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    FOR             reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    REPEAT          reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    WHILE           reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    CASE            reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    IF              reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    OUTPUT          reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    INPUT           reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    CONSTANT        reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    CALL            reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    FUNCTION        reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    PROCEDURE       reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    DECLARE         reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    IDENTIFIER      reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    $end            reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    UNTIL           reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    ENDPROCEDURE    reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    ENDWHILE        reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    ELSE            reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    ENDIF           reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    ENDFUNCTION     reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    NEXT            reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    OTHERWISE       reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    NUMBER          reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    STRING          reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    ENDCASE         reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    ,               reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)
    )               reduce using rule 6 (identifier_type -> IDENTIFIER : TYPE .)


state 115

    (38) expression -> IDENTIFIER ( arg_list ) .
    AND             reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    OR              reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    SMALLER         reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    BIGGER          reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    NOTEQUAL        reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    EQUAL           reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    *               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    /               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    +               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    -               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ?               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    RETURN          reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    FOR             reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    REPEAT          reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    WHILE           reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    CASE            reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    IF              reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    OUTPUT          reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    INPUT           reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    CONSTANT        reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    CALL            reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    FUNCTION        reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    PROCEDURE       reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    DECLARE         reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    IDENTIFIER      reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    $end            reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    UNTIL           reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ENDPROCEDURE    reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ENDWHILE        reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ELSE            reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ENDIF           reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ENDFUNCTION     reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    NEXT            reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    OTHERWISE       reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    NUMBER          reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    STRING          reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ENDCASE         reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    DO              reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    THEN            reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ,               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    ]               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    )               reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    TO              reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)
    STEP            reduce using rule 38 (expression -> IDENTIFIER ( arg_list ) .)


state 116

    (54) literal -> IDENTIFIER [ expression ] .
    AND             reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    OR              reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    SMALLER         reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    BIGGER          reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    NOTEQUAL        reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    EQUAL           reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    *               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    /               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    +               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    -               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ?               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    RETURN          reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    FOR             reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    REPEAT          reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    WHILE           reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    CASE            reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    IF              reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    OUTPUT          reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    INPUT           reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    CONSTANT        reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    CALL            reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    FUNCTION        reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    PROCEDURE       reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    DECLARE         reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    IDENTIFIER      reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    $end            reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    UNTIL           reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ENDPROCEDURE    reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ENDWHILE        reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ELSE            reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ENDIF           reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ENDFUNCTION     reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    NEXT            reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    OTHERWISE       reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    NUMBER          reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    STRING          reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ENDCASE         reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    DO              reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    THEN            reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ,               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    ]               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    )               reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    TO              reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)
    STEP            reduce using rule 54 (literal -> IDENTIFIER [ expression ] .)


state 117

    (12) statement -> FOR IDENTIFIER ASSIGN expression TO . expression STEP expression statement_list NEXT
    (13) statement -> FOR IDENTIFIER ASSIGN expression TO . expression statement_list NEXT
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 131
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 118

    (15) statement -> WHILE expression DO statement_list ENDWHILE .
    ?               reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    RETURN          reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    FOR             reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    REPEAT          reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    WHILE           reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    CASE            reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    IF              reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    OUTPUT          reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    INPUT           reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    CONSTANT        reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    CALL            reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    FUNCTION        reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    PROCEDURE       reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    DECLARE         reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    IDENTIFIER      reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    $end            reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    UNTIL           reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    ENDPROCEDURE    reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    ENDWHILE        reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    ELSE            reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    ENDIF           reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    ENDFUNCTION     reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    NEXT            reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    OTHERWISE       reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    NUMBER          reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    STRING          reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)
    ENDCASE         reduce using rule 15 (statement -> WHILE expression DO statement_list ENDWHILE .)


state 119

    (16) statement -> CASE OF expression caselist ENDCASE .
    ?               reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    RETURN          reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    FOR             reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    REPEAT          reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    WHILE           reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    CASE            reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    IF              reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    OUTPUT          reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    INPUT           reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    CONSTANT        reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    CALL            reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    FUNCTION        reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    PROCEDURE       reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    DECLARE         reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    IDENTIFIER      reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    $end            reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    UNTIL           reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    ENDPROCEDURE    reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    ENDWHILE        reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    ELSE            reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    ENDIF           reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    ENDFUNCTION     reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    NEXT            reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    OTHERWISE       reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    NUMBER          reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    STRING          reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)
    ENDCASE         reduce using rule 16 (statement -> CASE OF expression caselist ENDCASE .)


state 120

    (30) caselist -> a_case caselist .
    ENDCASE         reduce using rule 30 (caselist -> a_case caselist .)


state 121

    (32) a_case -> OTHERWISE : . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement                      shift and go to state 132
    variable                       shift and go to state 15

state 122

    (33) a_case -> constant_label : . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement                      shift and go to state 133
    variable                       shift and go to state 15

state 123

    (17) statement -> IF expression THEN statement_list ELSE . statement_list ENDIF
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 134
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 124

    (18) statement -> IF expression THEN statement_list ENDIF .
    ?               reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    RETURN          reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    FOR             reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    REPEAT          reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    WHILE           reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    CASE            reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    IF              reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    OUTPUT          reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    INPUT           reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    CONSTANT        reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    CALL            reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    FUNCTION        reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    PROCEDURE       reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    DECLARE         reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    IDENTIFIER      reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    $end            reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    UNTIL           reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    ENDPROCEDURE    reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    ENDWHILE        reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    ELSE            reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    ENDIF           reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    ENDFUNCTION     reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    NEXT            reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    OTHERWISE       reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    NUMBER          reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    STRING          reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)
    ENDCASE         reduce using rule 18 (statement -> IF expression THEN statement_list ENDIF .)


state 125

    (24) statement -> CALL IDENTIFIER ( arg_list ) .
    ?               reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    RETURN          reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    FOR             reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    REPEAT          reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    WHILE           reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    CASE            reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    IF              reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    OUTPUT          reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    INPUT           reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    CONSTANT        reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    CALL            reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    FUNCTION        reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    PROCEDURE       reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    DECLARE         reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    IDENTIFIER      reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    $end            reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    UNTIL           reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    ENDPROCEDURE    reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    ENDWHILE        reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    ELSE            reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    ENDIF           reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    ENDFUNCTION     reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    NEXT            reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    OTHERWISE       reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    NUMBER          reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    STRING          reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)
    ENDCASE         reduce using rule 24 (statement -> CALL IDENTIFIER ( arg_list ) .)


state 126

    (25) statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list . ENDFUNCTION
    ENDFUNCTION     shift and go to state 135


state 127

    (26) statement -> FUNCTION IDENTIFIER ( identifier_type_list ) . RETURNS TYPE statement_list ENDFUNCTION
    RETURNS         shift and go to state 136


state 128

    (8) identifier_type_list -> identifier_type , . identifier_type_list
    (7) identifier_type_list -> . empty
    (8) identifier_type_list -> . identifier_type , identifier_type_list
    (9) identifier_type_list -> . identifier_type
    (4) empty -> .
    (5) identifier_type -> . IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE
    (6) identifier_type -> . IDENTIFIER : TYPE
    )               reduce using rule 4 (empty -> .)
    IDENTIFIER      shift and go to state 46

    identifier_type                shift and go to state 110
    identifier_type_list           shift and go to state 137
    empty                          shift and go to state 109

state 129

    (28) statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) . statement_list ENDPROCEDURE
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 138
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 130

    (5) identifier_type -> IDENTIFIER : ARRAY [ . NUMBER : NUMBER ] OF TYPE
    NUMBER          shift and go to state 139


state 131

    (12) statement -> FOR IDENTIFIER ASSIGN expression TO expression . STEP expression statement_list NEXT
    (13) statement -> FOR IDENTIFIER ASSIGN expression TO expression . statement_list NEXT
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    STEP            shift and go to state 140
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 141
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 132

    (32) a_case -> OTHERWISE : statement .
    OTHERWISE       reduce using rule 32 (a_case -> OTHERWISE : statement .)
    NUMBER          reduce using rule 32 (a_case -> OTHERWISE : statement .)
    STRING          reduce using rule 32 (a_case -> OTHERWISE : statement .)
    ENDCASE         reduce using rule 32 (a_case -> OTHERWISE : statement .)


state 133

    (33) a_case -> constant_label : statement .
    OTHERWISE       reduce using rule 33 (a_case -> constant_label : statement .)
    NUMBER          reduce using rule 33 (a_case -> constant_label : statement .)
    STRING          reduce using rule 33 (a_case -> constant_label : statement .)
    ENDCASE         reduce using rule 33 (a_case -> constant_label : statement .)


state 134

    (17) statement -> IF expression THEN statement_list ELSE statement_list . ENDIF
    ENDIF           shift and go to state 142


state 135

    (25) statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .
    ?               reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    RETURN          reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    FOR             reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    REPEAT          reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    WHILE           reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    CASE            reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    IF              reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    OUTPUT          reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    INPUT           reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    CONSTANT        reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    CALL            reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    FUNCTION        reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    PROCEDURE       reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    DECLARE         reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    IDENTIFIER      reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    $end            reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    UNTIL           reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    ENDPROCEDURE    reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    ENDWHILE        reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    ELSE            reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    ENDIF           reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    ENDFUNCTION     reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    NEXT            reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    OTHERWISE       reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    NUMBER          reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    STRING          reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)
    ENDCASE         reduce using rule 25 (statement -> FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION .)


state 136

    (26) statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS . TYPE statement_list ENDFUNCTION
    TYPE            shift and go to state 143


state 137

    (8) identifier_type_list -> identifier_type , identifier_type_list .
    )               reduce using rule 8 (identifier_type_list -> identifier_type , identifier_type_list .)


state 138

    (28) statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list . ENDPROCEDURE
    ENDPROCEDURE    shift and go to state 144


state 139

    (5) identifier_type -> IDENTIFIER : ARRAY [ NUMBER . : NUMBER ] OF TYPE
    :               shift and go to state 145


state 140

    (12) statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP . expression statement_list NEXT
    (36) expression -> . literal
    (37) expression -> . IDENTIFIER ( )
    (38) expression -> . IDENTIFIER ( arg_list )
    (39) expression -> . expresssion_operation
    (40) expression -> . ( expression )
    (53) literal -> . IDENTIFIER
    (54) literal -> . IDENTIFIER [ expression ]
    (55) literal -> . STRING
    (56) literal -> . BOOL
    (57) literal -> . NUMBER . NUMBER
    (58) literal -> . NUMBER
    (59) literal -> . - NUMBER
    (43) expresssion_operation -> . expression AND expression
    (44) expresssion_operation -> . expression OR expression
    (45) expresssion_operation -> . expression SMALLER expression
    (46) expresssion_operation -> . expression BIGGER expression
    (47) expresssion_operation -> . expression NOTEQUAL expression
    (48) expresssion_operation -> . expression EQUAL expression
    (49) expresssion_operation -> . expression * expression
    (50) expresssion_operation -> . expression / expression
    (51) expresssion_operation -> . expression + expression
    (52) expresssion_operation -> . expression - expression
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    STRING          shift and go to state 28
    BOOL            shift and go to state 29
    NUMBER          shift and go to state 30
    -               shift and go to state 31

    expression                     shift and go to state 146
    literal                        shift and go to state 24
    expresssion_operation          shift and go to state 27

state 141

    (13) statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list . NEXT
    NEXT            shift and go to state 147


state 142

    (17) statement -> IF expression THEN statement_list ELSE statement_list ENDIF .
    ?               reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    RETURN          reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    FOR             reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    REPEAT          reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    WHILE           reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    CASE            reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    IF              reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    OUTPUT          reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    INPUT           reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    CONSTANT        reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    CALL            reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    FUNCTION        reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    PROCEDURE       reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    DECLARE         reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    IDENTIFIER      reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    $end            reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    UNTIL           reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    ENDPROCEDURE    reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    ENDWHILE        reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    ELSE            reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    ENDIF           reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    ENDFUNCTION     reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    NEXT            reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    OTHERWISE       reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    NUMBER          reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    STRING          reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)
    ENDCASE         reduce using rule 17 (statement -> IF expression THEN statement_list ELSE statement_list ENDIF .)


state 143

    (26) statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE . statement_list ENDFUNCTION
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 148
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 144

    (28) statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .
    ?               reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    RETURN          reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    FOR             reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    REPEAT          reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    WHILE           reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    CASE            reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    IF              reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    OUTPUT          reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    INPUT           reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    CONSTANT        reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    CALL            reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    FUNCTION        reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    PROCEDURE       reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    DECLARE         reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    IDENTIFIER      reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    $end            reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    UNTIL           reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    ENDPROCEDURE    reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    ENDWHILE        reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    ELSE            reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    ENDIF           reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    ENDFUNCTION     reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    NEXT            reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    OTHERWISE       reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    NUMBER          reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    STRING          reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)
    ENDCASE         reduce using rule 28 (statement -> PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE .)


state 145

    (5) identifier_type -> IDENTIFIER : ARRAY [ NUMBER : . NUMBER ] OF TYPE
    NUMBER          shift and go to state 149


state 146

    (12) statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression . statement_list NEXT
    (43) expresssion_operation -> expression . AND expression
    (44) expresssion_operation -> expression . OR expression
    (45) expresssion_operation -> expression . SMALLER expression
    (46) expresssion_operation -> expression . BIGGER expression
    (47) expresssion_operation -> expression . NOTEQUAL expression
    (48) expresssion_operation -> expression . EQUAL expression
    (49) expresssion_operation -> expression . * expression
    (50) expresssion_operation -> expression . / expression
    (51) expresssion_operation -> expression . + expression
    (52) expresssion_operation -> expression . - expression
    (2) statement_list -> . statement statement_list
    (3) statement_list -> . statement
    (10) statement -> . ? IDENTIFIER
    (11) statement -> . RETURN expression
    (12) statement -> . FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT
    (13) statement -> . FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT
    (14) statement -> . REPEAT statement_list UNTIL expression
    (15) statement -> . WHILE expression DO statement_list ENDWHILE
    (16) statement -> . CASE OF expression caselist ENDCASE
    (17) statement -> . IF expression THEN statement_list ELSE statement_list ENDIF
    (18) statement -> . IF expression THEN statement_list ENDIF
    (19) statement -> . OUTPUT arg_list
    (20) statement -> . INPUT IDENTIFIER
    (21) statement -> . CONSTANT IDENTIFIER = literal
    (22) statement -> . variable ASSIGN expression
    (23) statement -> . CALL IDENTIFIER
    (24) statement -> . CALL IDENTIFIER ( arg_list )
    (25) statement -> . FUNCTION IDENTIFIER RETURNS TYPE statement_list ENDFUNCTION
    (26) statement -> . FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION
    (27) statement -> . PROCEDURE IDENTIFIER statement_list ENDPROCEDURE
    (28) statement -> . PROCEDURE IDENTIFIER ( identifier_type_list ) statement_list ENDPROCEDURE
    (29) statement -> . DECLARE identifier_type
    (60) variable -> . IDENTIFIER
    (61) variable -> . IDENTIFIER [ expression ]
    AND             shift and go to state 48
    OR              shift and go to state 49
    SMALLER         shift and go to state 50
    BIGGER          shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUAL           shift and go to state 53
    *               shift and go to state 54
    /               shift and go to state 55
    +               shift and go to state 56
    -               shift and go to state 57
    ?               shift and go to state 4
    RETURN          shift and go to state 6
    FOR             shift and go to state 7
    REPEAT          shift and go to state 8
    WHILE           shift and go to state 9
    CASE            shift and go to state 10
    IF              shift and go to state 11
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    CONSTANT        shift and go to state 14
    CALL            shift and go to state 16
    FUNCTION        shift and go to state 17
    PROCEDURE       shift and go to state 18
    DECLARE         shift and go to state 19
    IDENTIFIER      shift and go to state 5

    statement_list                 shift and go to state 150
    statement                      shift and go to state 3
    variable                       shift and go to state 15

state 147

    (13) statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .
    ?               reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    RETURN          reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    FOR             reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    REPEAT          reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    WHILE           reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    CASE            reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    IF              reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    OUTPUT          reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    INPUT           reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    CONSTANT        reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    CALL            reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    FUNCTION        reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    PROCEDURE       reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    DECLARE         reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    IDENTIFIER      reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    $end            reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    UNTIL           reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    ENDPROCEDURE    reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    ENDWHILE        reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    ELSE            reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    ENDIF           reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    ENDFUNCTION     reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    NEXT            reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    OTHERWISE       reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    NUMBER          reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    STRING          reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)
    ENDCASE         reduce using rule 13 (statement -> FOR IDENTIFIER ASSIGN expression TO expression statement_list NEXT .)


state 148

    (26) statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list . ENDFUNCTION
    ENDFUNCTION     shift and go to state 151


state 149

    (5) identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER . ] OF TYPE
    ]               shift and go to state 152


state 150

    (12) statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list . NEXT
    NEXT            shift and go to state 153


state 151

    (26) statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .
    ?               reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    RETURN          reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    FOR             reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    REPEAT          reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    WHILE           reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    CASE            reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    IF              reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    OUTPUT          reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    INPUT           reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    CONSTANT        reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    CALL            reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    FUNCTION        reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    PROCEDURE       reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    DECLARE         reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    IDENTIFIER      reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    $end            reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    UNTIL           reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    ENDPROCEDURE    reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    ENDWHILE        reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    ELSE            reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    ENDIF           reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    ENDFUNCTION     reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    NEXT            reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    OTHERWISE       reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    NUMBER          reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    STRING          reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)
    ENDCASE         reduce using rule 26 (statement -> FUNCTION IDENTIFIER ( identifier_type_list ) RETURNS TYPE statement_list ENDFUNCTION .)


state 152

    (5) identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] . OF TYPE
    OF              shift and go to state 154


state 153

    (12) statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .
    ?               reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    RETURN          reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    FOR             reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    REPEAT          reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    WHILE           reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    CASE            reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    IF              reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    OUTPUT          reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    INPUT           reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    CONSTANT        reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    CALL            reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    FUNCTION        reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    PROCEDURE       reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    DECLARE         reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    IDENTIFIER      reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    $end            reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    UNTIL           reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    ENDPROCEDURE    reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    ENDWHILE        reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    ELSE            reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    ENDIF           reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    ENDFUNCTION     reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    NEXT            reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    OTHERWISE       reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    NUMBER          reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    STRING          reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)
    ENDCASE         reduce using rule 12 (statement -> FOR IDENTIFIER ASSIGN expression TO expression STEP expression statement_list NEXT .)


state 154

    (5) identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF . TYPE
    TYPE            shift and go to state 155


state 155

    (5) identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .
    ?               reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    RETURN          reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    FOR             reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    REPEAT          reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    WHILE           reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    CASE            reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    IF              reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    OUTPUT          reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    INPUT           reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    CONSTANT        reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    CALL            reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    FUNCTION        reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    PROCEDURE       reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    DECLARE         reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    IDENTIFIER      reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    $end            reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    UNTIL           reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    ENDPROCEDURE    reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    ENDWHILE        reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    ELSE            reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    ENDIF           reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    ENDFUNCTION     reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    NEXT            reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    OTHERWISE       reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    NUMBER          reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    STRING          reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    ENDCASE         reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    ,               reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
    )               reduce using rule 5 (identifier_type -> IDENTIFIER : ARRAY [ NUMBER : NUMBER ] OF TYPE .)
